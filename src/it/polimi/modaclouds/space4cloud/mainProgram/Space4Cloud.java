/*******************************************************************************
 * Copyright 2014 Giovanni Paolo Gibilisco
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package it.polimi.modaclouds.space4cloud.mainProgram;

import it.polimi.modaclouds.space4cloud.gui.AssesmentWindow;
import it.polimi.modaclouds.space4cloud.gui.Choose;
import it.polimi.modaclouds.space4cloud.gui.LoadModel;
import it.polimi.modaclouds.space4cloud.gui.OptimizationProgressWindow;
import it.polimi.modaclouds.space4cloud.gui.XMLFileSelection;
import it.polimi.modaclouds.space4cloud.optimization.OptEngine;
import it.polimi.modaclouds.space4cloud.optimization.PartialEvaluationOptimizationEngine;
import it.polimi.modaclouds.space4cloud.optimization.constraints.ConstraintHandler;
import it.polimi.modaclouds.space4cloud.utils.ConfigurationHandler;
import it.polimi.modaclouds.space4cloud.utils.Constants;
import it.polimi.modaclouds.space4cloud.utils.RunConfigurationsHandler;
import it.polimi.modaclouds.space4cloud.utils.SimpleEvaluator;

import java.io.File;
import java.io.FilenameFilter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import javax.swing.SwingWorker;

import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.NullProgressMonitor;

import de.uka.ipd.sdq.pcmsolver.runconfig.MessageStrings;

public class Space4Cloud extends SwingWorker<Object, Object> {


	//	private static Logger logger = LoggerFactory.getLogger(Main.class);
	private static OptimizationProgressWindow progressWindow;
	private static AssesmentWindow assesmentWindow;
	private Constants	c;

	@Override
	protected Object doInBackground() throws Exception {

		/*Ask for the functionality*/
		Choose assesmentChoiche = new Choose("Functionality selection",
				"Choose the desired functionality","Assesment","Optimization", false);		
		if(!assesmentChoiche.isChosen()) return null;

		/*Load the resourceEnvironment*/
		LoadModel lm = new LoadModel(null,"Resource Model",".resourceenvironment");
		if(!lm.isChosen()) return null;
		File resourceEnvironmentFile = lm.getModelFile();		


		/*Initialize constants*/
		String modelsDirectory = resourceEnvironmentFile.getAbsolutePath();
		modelsDirectory = modelsDirectory.substring(0,modelsDirectory.lastIndexOf(File.separator));
		Constants.clear();
		Constants.setWorkingDirectory(modelsDirectory);		
		c = Constants.getInstance();
		c.RESOURCE_MODEL = resourceEnvironmentFile.getAbsolutePath();

		/*Look for the config files generated by previous runs that stores other models*/
		Path confFilePath = Paths.get(c.ABSOLUTE_WORKING_DIRECTORY+c.CONFIG_FILE_NAME);	
		ConfigurationHandler confHandler = new ConfigurationHandler(confFilePath);


		//if there exists a configuration file load it 
		if (confFilePath.toFile().exists()) {
			confHandler.loadConfiguration();			
		}
		//if there is no configuration file then generate a valid configuration
		else{
			//delete any old space4cloud folder
			ConfigurationHandler.cleanFolders(c.ABSOLUTE_WORKING_DIRECTORY);

			//load the usage model
			lm = new LoadModel(null, "Usage Model", ".usagemodel");
			if(!lm.isChosen()) return null;
			c.USAGE_MODEL=lm.getModelFile().getAbsolutePath();


			//load the allocation model
			lm = new LoadModel(null, "Allocation Model", ".allocation");
			if(!lm.isChosen()) return null;
			c.ALLOCATION_MODEL=lm.getModelFile().getAbsolutePath();

			//load the repository model
			lm = new LoadModel(null, "Repository Model", ".repository");
			if(!lm.isChosen()) return null;
			c.REPOSITORY_MODEL=lm.getModelFile().getAbsolutePath();

			//load the solver
			Choose choice = new Choose("Choose the Solver", "Which Solver do you want to use?");
			if(!choice.isChosen()) return null;
			c.SOLVER = choice.getSolver();
			//if the solver is LINE it needs the path to its configuration file	
			if(c.SOLVER.equals(MessageStrings.PERFENGINE_SOLVER)){
				lm = new LoadModel(	null, "Performance Engine Config", ".properties");
				if(!lm.isChosen()) return null;
				c.LINE_PROPERTIES_FILE = lm.getModelFile().getAbsolutePath();
			}

			//save the configuration, it will be run later in the optimization process
			confHandler.saveConfiguration();
			//refresh the project in the workspace
			refreshProject();


		}



		//Build the run configuration
		RunConfigurationsHandler runConfigHandler = new RunConfigurationsHandler();
		//launch it
		runConfigHandler.launch();

		//Build the folder structure to host results and copy the LQN model in those folders		
		File resultDirPath = Paths.get(c.ABSOLUTE_WORKING_DIRECTORY, c.PERFORMANCE_RESULTS_FOLDER).toFile();		
		//list files excluding the result file generated by the solver 
		File[] modelFiles = resultDirPath.listFiles(new FilenameFilter() {			
			@Override
			public boolean accept(File dir, String name) {				
				return name.endsWith(".xml") && !name.contains("_res");
			}
		});
		File[] resultFiles = resultDirPath.listFiles(new FilenameFilter() {			
			@Override
			public boolean accept(File dir, String name) {				
				return name.endsWith("_res.xml") || name.endsWith(".lqxo");
			}
		});

		//if the palladio run has not produced a lqn model exit
		if(modelFiles.length!=1 || resultFiles.length!=1){
			System.err.println("The first initialization run has encounter some problem during the generation of the first solution");
			System.err.println("SPACE4CLOUD will now exit.");
			return null;
		}

		//there should be just 1 palladio model 		
		Path lqnModelPath = modelFiles[0].toPath();
		//with the corresponding evaluation
		Path resultModelPath = resultFiles[0].toPath();
		for(int i=0;i<24;i++){			
			Path tmpFolderPath = Paths.get(c.ABSOLUTE_WORKING_DIRECTORY, c.PERFORMANCE_RESULTS_FOLDER,c.FOLDER_PREFIX+i);
			Files.createDirectory(tmpFolderPath);
			Path tmpLqnPath = Paths.get(c.ABSOLUTE_WORKING_DIRECTORY, c.PERFORMANCE_RESULTS_FOLDER,c.FOLDER_PREFIX+i,lqnModelPath.getFileName().toString());			
			Files.copy(lqnModelPath,tmpLqnPath);
			Path tmpResultPath = Paths.get(c.ABSOLUTE_WORKING_DIRECTORY, c.PERFORMANCE_RESULTS_FOLDER,c.FOLDER_PREFIX+i,resultModelPath.getFileName().toString());			
			Files.copy(resultModelPath,tmpResultPath);
		}
		//refresh the workspace
		refreshProject();




		/*TODO: continue from here
		We should have the generated lqn model in the result folder. now we need to:
		3)load the initial solution (leave modification and first real evaluation there) 		
		 */

		/*Load the Extension file*/
		XMLFileSelection extensionSelector = new XMLFileSelection("Load Extension");		
		File extensionFile = extensionSelector.getFile();
		if(extensionFile == null) return null;
		c.EXTENSION_FILE = extensionFile.getAbsolutePath();

		if(!assesmentChoiche.isTrue()){

			/*Load the Constraint file*/
			System.out.println("Parsing Constraints");
			XMLFileSelection constraintSelector = new XMLFileSelection("Load Constraints");			
			File constraintFile = constraintSelector.getFile();
			if(constraintFile == null) return null;			

			//Parse the constraints and initialize the handler
			ConstraintHandler constraintHandler = new ConstraintHandler();
			constraintHandler.loadConstraints(constraintFile);

			//Build a new Optimization Engine engine and an empty initial solution
			System.out.println("Loading the optimization enging and perparing the solver");
			OptEngine engine = new PartialEvaluationOptimizationEngine(constraintHandler);

			//load the initial solution from the PCM specified in the configuration and the extension
			System.out.println("Parsing The Solution");
			engine.loadInitialSolution(extensionFile);
			
			engine.SerializeInitialSolution(Paths.get(c.ABSOLUTE_WORKING_DIRECTORY,"Solution.ser").toFile());
			
			engine.loadInitialSolutionObject(Paths.get(c.ABSOLUTE_WORKING_DIRECTORY,"Solution.ser").toFile());

			//create the progress window
			progressWindow = new OptimizationProgressWindow();
			progressWindow.setMax(engine.getMaxIterations());
			progressWindow.setCostLogger(engine.getCostLogger());
			progressWindow.setVMLogger(engine.getVMLogger());
			progressWindow.setConstraintsLogger(engine.getConstraintsLogger());
			engine.addPropertyChangeListener(progressWindow);
			engine.getEvalProxy().addPropertyChangeListener(progressWindow);

			//start the optimization
			System.out.println("Starting the optimization");
			engine.execute();

		}
		//otherwise just evaluate the extended solution
		//TODO: fix this, it is based on old implementation
		else{
			confHandler.removeOldLQNFiles();
			SimpleEvaluator evaluator = new SimpleEvaluator();			
			//evaluator.loadSolution(extensionFile);
			evaluator.eval();
			evaluator.parseResults();
			assesmentWindow = new AssesmentWindow();
			assesmentWindow.setVMLogger(evaluator.getVMLogger());
			assesmentWindow.setResponseTimeLogger(evaluator.getRTLogger());
			assesmentWindow.setUtilizationLogger(evaluator.getUtilLogger());	
			assesmentWindow.show();			
			assesmentWindow.updateImages();		

		}
		return null;
	}


	private void refreshProject() {
		try {
			ResourcesPlugin
			.getWorkspace()
			.getRoot()
			.getProject(c.PROJECT_NAME)
			.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
		} catch (CoreException e) {
			e.printStackTrace();
		}
	}

}

