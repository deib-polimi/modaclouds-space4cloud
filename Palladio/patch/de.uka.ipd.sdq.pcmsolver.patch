Index: .classpath
===================================================================
--- .classpath	(revision 26823)
+++ .classpath	(working copy)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="resources"/>
Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 26823)
+++ .settings/org.eclipse.jdt.core.prefs	(working copy)
@@ -1,7 +1,7 @@
-#Wed Apr 22 06:02:19 CEST 2009
 eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.compliance=1.7
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.compiler.source=1.7
Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 26823)
+++ META-INF/MANIFEST.MF	(working copy)
@@ -45,6 +45,7 @@
  de.uka.ipd.sdq.pcmsolver.visitors,
  de.uka.ipd.sdq.pcmsolver.visualisation
 Bundle-RequiredExecutionEnvironment: JavaSE-1.6
-Import-Package: org.eclipse.ui.part,
+Import-Package: org.apache.commons.lang.time,
+ org.eclipse.ui.part,
  org.eclipse.ui.views.navigator
 Bundle-Vendor: sdq.ipd.uka.de
Index: build.properties
===================================================================
--- build.properties	(revision 26823)
+++ build.properties	(working copy)
@@ -2,5 +2,7 @@
 bin.includes = plugin.xml,\
                META-INF/,\
                icons/,\
-               .
+               .,\
+               resources/
 source.. = src/
+src.includes = resources/
Index: src/de/uka/ipd/sdq/pcmsolver/RunPCMAnalysisJob.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/RunPCMAnalysisJob.java	(revision 26823)
+++ src/de/uka/ipd/sdq/pcmsolver/RunPCMAnalysisJob.java	(working copy)
@@ -69,8 +69,9 @@
 			strategy = new Pcm2RegExStrategy(configuration);
 		} else if (configuration.getSolver().equals(MessageStrings.LQNS_SOLVER)) {
 			strategy = new Pcm2LqnStrategy(configuration);
-		} else if (configuration.getSolver()
-				.equals(MessageStrings.LQSIM_SOLVER)) {
+		} else if (configuration.getSolver().equals(MessageStrings.PERFENGINE_SOLVER)) {
+			strategy = new Pcm2LqnStrategy(configuration);
+		} else if (configuration.getSolver().equals(MessageStrings.LQSIM_SOLVER)) {
 			strategy = new Pcm2LqnStrategy(configuration);
 		}
 
@@ -125,8 +126,7 @@
 		return "Run PCM Analysis";
 	}
 
-	public void cleanup(IProgressMonitor monitor)
-			throws CleanupFailedException {
+	public void cleanup(IProgressMonitor monitor) throws CleanupFailedException {
 		// Nothing to do here
 	}
 }
Index: src/de/uka/ipd/sdq/pcmsolver/runconfig/MainConfigTab.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/runconfig/MainConfigTab.java	(revision 26823)
+++ src/de/uka/ipd/sdq/pcmsolver/runconfig/MainConfigTab.java	(working copy)
@@ -1,8 +1,12 @@
+/*
+ * 
+ */
 package de.uka.ipd.sdq.pcmsolver.runconfig;
 
 import java.util.ArrayList;
 
 import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.debug.core.ILaunchConfiguration;
 import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy;
@@ -21,48 +25,108 @@
 import org.eclipse.swt.widgets.Combo;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.DirectoryDialog;
+import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Text;
 
 import de.uka.ipd.sdq.workflow.pcm.runconfig.FileNamesInputTab;
 
+// TODO: Auto-generated Javadoc
+/**
+ * The Class MainConfigTab.
+ */
 public class MainConfigTab extends FileNamesInputTab {
 
+	/** The text sampling dist. */
 	private Text textSamplingDist;
+
+	/** The text max domain. */
 	private Text textMaxDomain;
-	
+
+	/** The lqns config1. */
 	private Text lqnsConfig1;
+
+	/** The lqns config2. */
 	private Text lqnsConfig2;
+
+	/** The lqns config3. */
 	private Text lqnsConfig3;
+
+	/** The lqns config4. */
 	private Text lqnsConfig4;
+
+	/** The lqns config stop on message loss. */
 	private Button  lqnsConfigStopOnMessageLoss;
+
+	/** The lqns config stop on message loss. */
+	private Button  debugButton;
+
+	/** The lqns config inf task mult. */
 	private Button  lqnsConfigInfTaskMult;
+
+	/** The combo lqns output. */
 	protected Combo comboLqnsOutput;
-		
+
+	/** The lqsim config1. */
 	private Text lqsimConfig1;
+
+	/** The lqsim config2. */
 	private Text lqsimConfig2;
+
+	/** The lqsim config3. */
 	private Text lqsimConfig3;
+
+	/** The lqsim config stop on message loss. */
 	private Button  lqsimConfigStopOnMessageLoss;
+
+	/** The combo lqsim output. */
 	protected Combo comboLqsimOutput;
-	
+
+	/** The lqns config pragma. */
 	private Text lqnsConfigPragma;
+
+	/** The lqnsim config pragma. */
 	private Text lqnsimConfigPragma;
-	
+
+	/** The sres config group. */
 	private Group sresConfigGroup; 
+
+	/** The sres config group. */
+	private Group perfengineConfigGroup; 
+
+	/** The lqns config group. */
 	private Group lqnsConfigGroup; 
+
+	/** The lqsim config group. */
 	private Group lqsimConfigGroup;
 
+	/** The stack layout. */
 	private StackLayout stackLayout;
-	
+
+	/** The combo solver. */
 	protected Combo comboSolver;
+
+	/** The text lqns output dir. */
 	private Text textLqnsOutputDir;	
+
+	/** The text performance engine output dir. */
+	private Text textPerfEngOutputDir;	
+
+	/** The text performance engine output dir. */
+	private Text textPerfEngPropFile;
+
+	/** The text lqsim output dir. */
 	private Text textLqsimOutputDir;
+
+	/** The text sre output file. */
 	private Text textSREOutputFile;
-	
+
+	/** The checkbox use expression as input. */
 	private Button checkboxUseExpressionAsInput;
-	
+
 	// Create a listener for GUI modification events:
+	/** The listener. */
 	final ModifyListener listener = new ModifyListener() {
 
 		public void modifyText(ModifyEvent e) {
@@ -70,15 +134,30 @@
 			MainConfigTab.this.updateLaunchConfigurationDialog();
 		}
 	};
-	
-//	private class MainConfigTabListener extends SelectionAdapter implements ModifyListener {
-//		public void modifyText(ModifyEvent e) {
-//			updateLaunchConfigurationDialog();
-//			MainConfigTab.this.setDirty(true);
-//		}
-//	}
+
+	//	private class MainConfigTabListener extends SelectionAdapter implements ModifyListener {
+	//		public void modifyText(ModifyEvent e) {
+	//			updateLaunchConfigurationDialog();
+	//			MainConfigTab.this.setDirty(true);
+	//		}
+	//	}
 
+	/**
+	 * The listener interface for receiving comboBox events.
+	 * The class that is interested in processing a comboBox
+	 * event implements this interface, and the object created
+	 * with that class is registered with a component using the
+	 * component's <code>addComboBoxListener<code> method. When
+	 * the comboBox event occurs, that object's appropriate
+	 * method is invoked.
+	 *
+	 * @see ComboBoxEvent
+	 */
 	private class ComboBoxListener extends SelectionAdapter implements SelectionListener{
+
+		/* (non-Javadoc)
+		 * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)
+		 */
 		@Override
 		public void widgetSelected(SelectionEvent e) {
 			super.widgetSelected(e);
@@ -87,44 +166,56 @@
 		}
 	}
 
-	
+
 	//private MainConfigTabListener listener = new MainConfigTabListener();
+	/** The combo listener. */
 	private ComboBoxListener comboListener = new ComboBoxListener();
 
-	
 
-	
+
+
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.FileNamesInputTab#createControl(org.eclipse.swt.widgets.Composite)
+	 */
 	@Override
 	public void createControl(Composite parent) {
 		Composite container = new Composite(parent, SWT.NONE);
 		setControl(container);
 		container.setLayout(new GridLayout());
-		
+
 		comboSolver = new Combo (container, SWT.READ_ONLY);
 		comboSolver.setItems (new String [] {
 				MessageStrings.SRE_SOLVER,
 				MessageStrings.LQNS_SOLVER,
-				MessageStrings.LQSIM_SOLVER
-				});
+				MessageStrings.LQSIM_SOLVER,
+				MessageStrings.PERFENGINE_SOLVER
+		});
 		comboSolver.setSize (400, 200);
 		comboSolver.addModifyListener(listener);
 		comboSolver.addSelectionListener(comboListener);
-		
+
 		Composite innerContainer = new Composite(container, SWT.NONE);
 		stackLayout = new StackLayout();
 		innerContainer.setLayout(stackLayout);
 		innerContainer.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, true, 1, 1));
 
-		
+
 		sresConfigGroup = createSREWidgets(innerContainer);
 		lqnsConfigGroup = createLQNSWidgets(innerContainer);
 		lqsimConfigGroup = createLQSIMWidgets(innerContainer);
+		perfengineConfigGroup = createPerfEngWidgets(innerContainer);
 	}
 
-	
-	
+
+
+	/**
+	 * Creates the lqsim widgets.
+	 *
+	 * @param container the container
+	 * @return the group
+	 */
 	private Group createLQSIMWidgets(Composite container) {
-		
+
 		final SelectionListener selectionListener = new SelectionListener() {
 
 			public void widgetDefaultSelected(SelectionEvent e) {
@@ -137,7 +228,7 @@
 				MainConfigTab.this.updateLaunchConfigurationDialog();
 			}
 		};
-		
+
 		final GridLayout analysisGL = new GridLayout();
 		analysisGL.numColumns = 4;
 
@@ -148,11 +239,11 @@
 
 		GridData threeColumnGridData = new GridData(SWT.LEFT, SWT.CENTER, true, false);
 		threeColumnGridData.horizontalSpan = 3;
-		
+
 		Label label1 = new Label(group, SWT.NONE);
 		label1.setText("Run Time (optional):");
 		label1.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqsimConfig1 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqsimConfig1.setLayoutData(threeColumnGridData);
 		lqsimConfig1.addModifyListener(listener);
@@ -160,7 +251,7 @@
 		Label label2 = new Label(group, SWT.NONE);
 		label2.setText("Blocks (optional):");
 		label2.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqsimConfig2 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqsimConfig2.setLayoutData(threeColumnGridData);
 		lqsimConfig2.addModifyListener(listener);
@@ -168,15 +259,15 @@
 		Label label3 = new Label(group, SWT.NONE);
 		label3.setText("Processor Sharing Time Quantum:");
 		label3.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqsimConfig3 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqsimConfig3.setLayoutData(threeColumnGridData);
 		lqsimConfig3.addModifyListener(listener);
-		
+
 		Label labelStopOnMessageLoss = new Label(group, SWT.NONE);
 		labelStopOnMessageLoss.setText("\"Stop On Message Loss\" Pragma:");
 		labelStopOnMessageLoss.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqsimConfigStopOnMessageLoss = new Button(group,  SWT.CHECK);
 		lqsimConfigStopOnMessageLoss.setEnabled(true);
 		lqsimConfigStopOnMessageLoss.setText("Stop on message loss");
@@ -187,32 +278,32 @@
 		Label label4 = new Label(group, SWT.NONE);
 		label4.setText("Output Type:");
 		label4.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		comboLqsimOutput = new Combo(group, SWT.READ_ONLY);
 		comboLqsimOutput.setItems (new String [] {
 				MessageStrings.LQN_OUTPUT_HTML,
 				MessageStrings.LQN_OUTPUT_HUMAN,
 				MessageStrings.LQN_OUTPUT_XML
-				});
+		});
 		comboLqsimOutput.setSize (400, 200);
 		comboLqsimOutput.setLayoutData(threeColumnGridData);
 		comboLqsimOutput.addModifyListener(listener);
-//		comboLqsimOutput.addSelectionListener(comboListener);
+		//		comboLqsimOutput.addSelectionListener(comboListener);
 
 		Label label5 = new Label(group, SWT.NONE);
 		label5.setText("Output Dir:");
 		label5.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		textLqsimOutputDir = new Text(group, SWT.SINGLE | SWT.BORDER);
 		textLqsimOutputDir.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
 		textLqsimOutputDir.addModifyListener(listener);
 
 		createFolderSelectionButtons(group,textLqsimOutputDir);
-		
+
 		Label labelPragma = new Label(group, SWT.NONE);
 		labelPragma.setText("Additional Pragmas:");
 		labelPragma.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsimConfigPragma = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqnsimConfigPragma.setLayoutData(threeColumnGridData);
 		lqnsimConfigPragma.addModifyListener(listener);
@@ -222,6 +313,12 @@
 
 
 
+	/**
+	 * Creates the lqns widgets.
+	 *
+	 * @param container the container
+	 * @return the group
+	 */
 	private Group createLQNSWidgets(Composite container) {
 		final SelectionListener selectionListener = new SelectionListener() {
 
@@ -235,7 +332,7 @@
 				MainConfigTab.this.updateLaunchConfigurationDialog();
 			}
 		};
-		
+
 		final GridLayout analysisGL = new GridLayout();
 		analysisGL.numColumns = 4;
 
@@ -250,109 +347,199 @@
 		Label label1 = new Label(group, SWT.NONE);
 		label1.setText("Convergence Value:");
 		label1.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfig1 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqnsConfig1.setLayoutData(threeColumnGridData);
 		lqnsConfig1.addModifyListener(listener);
-		
+
 		Label label2 = new Label(group, SWT.NONE);
 		label2.setText("Iteration Limit:");
 		label2.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfig2 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqnsConfig2.setLayoutData(threeColumnGridData);
 		lqnsConfig2.addModifyListener(listener);
-		
+
 		Label label3 = new Label(group, SWT.NONE);
 		label3.setText("Print Interval Intermediate Results:");
 		label3.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfig3 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqnsConfig3.setLayoutData(threeColumnGridData);
 		lqnsConfig3.addModifyListener(listener);
-		
+
 		Label label4 = new Label(group, SWT.NONE);
 		label4.setText("Under-relaxation Coefficient:");
 		label4.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfig4 = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqnsConfig4.setLayoutData(threeColumnGridData);
 		lqnsConfig4.addModifyListener(listener);
-		
+
 		Label labelStopOnMessageLoss = new Label(group, SWT.NONE);
 		labelStopOnMessageLoss.setText("\"Stop On Message Loss\" Pragma:");
 		labelStopOnMessageLoss.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfigStopOnMessageLoss = new Button(group,  SWT.CHECK);
 		lqnsConfigStopOnMessageLoss.setEnabled(true);
 		lqnsConfigStopOnMessageLoss.setText("Stop on message loss");
 		lqnsConfigStopOnMessageLoss.addSelectionListener(selectionListener);
 		lqnsConfigStopOnMessageLoss.setSelection(true);
 		lqnsConfigStopOnMessageLoss.setLayoutData(threeColumnGridData);
-		
+
 		Label labelInfTaskMult = new Label(group, SWT.NONE);
 		labelInfTaskMult.setText("Infinite Task Multiplicity:");
 		labelInfTaskMult.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfigInfTaskMult = new Button(group,  SWT.CHECK);
 		lqnsConfigInfTaskMult.setEnabled(true);
 		lqnsConfigInfTaskMult.setText("");
 		lqnsConfigInfTaskMult.addSelectionListener(selectionListener);
 		lqnsConfigInfTaskMult.setSelection(true);
 		lqnsConfigInfTaskMult.setLayoutData(threeColumnGridData);
-		
+
 		Label label5 = new Label(group, SWT.NONE);
 		label5.setText("Output Type:");
 		label5.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		comboLqnsOutput = new Combo(group, SWT.READ_ONLY);
 		comboLqnsOutput.setItems (new String [] {
 				MessageStrings.LQN_OUTPUT_HTML,
 				MessageStrings.LQN_OUTPUT_HUMAN,
 				MessageStrings.LQN_OUTPUT_XML
-				});
+		});
 		comboLqnsOutput.setSize (400, 200);
 		comboLqnsOutput.setLayoutData(threeColumnGridData);
 		comboLqnsOutput.addModifyListener(listener);
 		comboLqnsOutput.addSelectionListener(comboListener);
-		
+
 		Label label6 = new Label(group, SWT.NONE);
 		label6.setText("Output Dir:");
 		label6.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		textLqnsOutputDir = new Text(group, SWT.SINGLE | SWT.BORDER);
 		textLqnsOutputDir.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
 		textLqnsOutputDir.addModifyListener(listener);
 
 		createFolderSelectionButtons(group,textLqnsOutputDir);
-		
+
 		Label labelPragma = new Label(group, SWT.NONE);
 		labelPragma.setText("Additional Pragmas:");
 		labelPragma.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		lqnsConfigPragma = new Text(group, SWT.SINGLE | SWT.BORDER);
 		lqnsConfigPragma.setLayoutData(threeColumnGridData);
 		lqnsConfigPragma.addModifyListener(listener);
+
+		return group;
+	}
+
+	/**
+	 * Creates the lqns widgets.
+	 *
+	 * @param container the container
+	 * @return the group
+	 */
+	private Group createPerfEngWidgets(Composite container) {
+		final SelectionListener selectionListener = new SelectionListener() {
+
+			public void widgetDefaultSelected(SelectionEvent e) {
+				MainConfigTab.this.setDirty(true);
+				MainConfigTab.this.updateLaunchConfigurationDialog();
+			}
+
+			public void widgetSelected(SelectionEvent e) {
+				MainConfigTab.this.setDirty(true);
+				MainConfigTab.this.updateLaunchConfigurationDialog();
+			}
+		};
+
+		final GridLayout analysisGL = new GridLayout();
+		analysisGL.numColumns = 4;
+
+		final Group group = new Group(container, SWT.NONE);
+		group.setLayout(analysisGL);
+		group.setText("Configuration (Definition of parameters)");
+		group.setLayoutData(new GridData(500, SWT.DEFAULT));
+
+		GridData threeColumnGridData = new GridData(SWT.LEFT, SWT.CENTER, true, false);
+		threeColumnGridData.horizontalSpan = 3;
+
+	
+
+		Label labelOutFolder = new Label(group, SWT.NONE);
+		labelOutFolder.setText("Output Dir:");
+		labelOutFolder.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+
+		textPerfEngOutputDir = new Text(group, SWT.SINGLE | SWT.BORDER);
+		textPerfEngOutputDir.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
+		textPerfEngOutputDir.addModifyListener(listener);
+
+
+		createFolderSelectionButtons(group,textPerfEngOutputDir);
 		
+		Label labelPerfFile = new Label(group, SWT.NONE);
+		labelPerfFile.setText("LINE property file:");
+		labelPerfFile.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+
+		textPerfEngPropFile = new Text(group, SWT.SINGLE | SWT.BORDER);
+		textPerfEngPropFile.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
+		textPerfEngPropFile.addModifyListener(listener);
+		
+		createFileSelectionButtons(group,textPerfEngPropFile);
+
+		debugButton = new Button(group,  SWT.CHECK);
+		debugButton.setEnabled(true);
+		debugButton.setText("Verbose Debugging");
+		debugButton.addSelectionListener(selectionListener);
+		debugButton.setSelection(true);
+		debugButton.setLayoutData(threeColumnGridData);	
 		return group;
 	}
 
 
 
+	/**
+	 * Creates the folder selection buttons.
+	 *
+	 * @param group the group
+	 * @param text the text
+	 */
 	private void createFolderSelectionButtons(final Group group, Text text) {
 		final Button workspaceButton = new Button(group, SWT.NONE);
 		workspaceButton.setText("Workspace...");
 		workspaceButton.addSelectionListener(new WorkspaceButtonSelectionListener(text));
-		
+
 		final Button fileSystemButton = new Button(group, SWT.NONE);
 		fileSystemButton.setText("File System...");
 		fileSystemButton.addSelectionListener(new FileSystemButtonSelectionAdapter(text));
 	}
 
+	/**
+	 * Creates the file selection buttons.
+	 *
+	 * @param group the group
+	 * @param text the text
+	 */
+	private void createFileSelectionButtons(final Group group, Text text) {
+		final Button workspaceButton = new Button(group, SWT.NONE);
+		workspaceButton.setText("Workspace...");
+		workspaceButton.addSelectionListener(new WorkspaceFileButtonSelectionListener(text));
+
+		final Button fileSystemButton = new Button(group, SWT.NONE);
+		fileSystemButton.setText("File System...");
+		fileSystemButton.addSelectionListener(new FileSystemButtonSelectionAdapter(text));
+	}
 
 
+	/**
+	 * Creates the sre widgets.
+	 *
+	 * @param container the container
+	 * @return the group
+	 */
 	private Group createSREWidgets(Composite container) {
-		
+
 		final SelectionListener selectionListener = new SelectionListener() {
 
 			public void widgetDefaultSelected(SelectionEvent e) {
@@ -365,14 +552,14 @@
 				MainConfigTab.this.updateLaunchConfigurationDialog();
 			}
 		};
-		
+
 		final GridLayout analysisGL = new GridLayout();
 		analysisGL.numColumns = 4;
-		
+
 		GridData threeColumnGridData = new GridData(SWT.LEFT, SWT.CENTER, true, false);
 		threeColumnGridData.horizontalSpan = 3;
-		
-	
+
+
 		final Group group = new Group(container, SWT.NONE);
 		group.setLayout(analysisGL);
 		group.setText("Configuration");
@@ -381,23 +568,23 @@
 		Label samplingDist = new Label(group, SWT.NONE);
 		samplingDist.setText("Sampling Distance:");
 		samplingDist.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		textSamplingDist = new Text(group, SWT.SINGLE | SWT.BORDER);
 		textSamplingDist.setLayoutData(threeColumnGridData);
 		textSamplingDist.addModifyListener(listener);
-		
+
 		Label maxDomain = new Label(group, SWT.NONE);
 		maxDomain.setText("Maximum Domain Size:");
 		maxDomain.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		textMaxDomain = new Text(group, SWT.SINGLE | SWT.BORDER);
 		textMaxDomain.setLayoutData(threeColumnGridData);
 		textMaxDomain.addModifyListener(listener);
-		
+
 		Label useExpressionLabel = new Label(group, SWT.NONE);
 		useExpressionLabel.setText("Use of Expression Model File:");
 		useExpressionLabel.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		// Create the check box to choose whether Expression model should be read in
 		checkboxUseExpressionAsInput = new Button(group,  SWT.CHECK);
 		checkboxUseExpressionAsInput.setEnabled(true);
@@ -405,11 +592,11 @@
 		checkboxUseExpressionAsInput.addSelectionListener(selectionListener);
 		checkboxUseExpressionAsInput.setLayoutData(threeColumnGridData);
 		checkboxUseExpressionAsInput.setSelection(false);
-		
+
 		Label label6 = new Label(group, SWT.NONE);
 		label6.setText("Expression Model File:");
 		label6.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));
-		
+
 		textSREOutputFile = new Text(group, SWT.SINGLE | SWT.BORDER);
 		textSREOutputFile.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));
 		textSREOutputFile.addModifyListener(listener);
@@ -418,16 +605,22 @@
 		//String[] filenameExtensions = {".expression", ".spa"};
 		//this.createFileInputSection(group, modifyListener, "Expression Model File (use as input or output):", filenameExtensions, textSREOutputFile);
 		createFolderSelectionButtons(group,textSREOutputFile);
-				
+
 		return group;
 
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.ProtocomFileNamesInputTab#getName()
+	 */
 	@Override
 	public String getName() {
 		return "Solver";
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.FileNamesInputTab#initializeFrom(org.eclipse.debug.core.ILaunchConfiguration)
+	 */
 	@Override
 	public void initializeFrom(ILaunchConfiguration configuration) {
 		try{
@@ -456,8 +649,7 @@
 			}
 		} catch(CoreException e){
 			comboLqnsOutput.select(0);
-		}
-		try{
+		}try{
 			String outputStr = configuration.getAttribute(MessageStrings.LQSIM_OUTPUT, 
 					MessageStrings.LQN_OUTPUT_HUMAN);
 			String[] items = comboLqsimOutput.getItems();
@@ -485,8 +677,8 @@
 		} catch(CoreException e){
 			textSREOutputFile.setText(System.getProperty("user.dir"));
 		}
-		
-		
+
+
 		try{
 			lqnsConfig1.setText(configuration.getAttribute(MessageStrings.CONV_VALUE, "0.001"));
 		} catch(CoreException e){
@@ -507,19 +699,31 @@
 		} catch(CoreException e){
 			lqnsConfig4.setText("0.5");
 		}
-		
+
 		try{
 			textLqnsOutputDir.setText(configuration.getAttribute(MessageStrings.LQNS_OUTPUT_DIR, System.getProperty("user.dir")));
 		} catch(CoreException e){
 			textLqnsOutputDir.setText(System.getProperty("user.dir"));
 		}
-		
+
+		try{
+			textPerfEngOutputDir.setText(configuration.getAttribute(MessageStrings.LINE_OUT_DIR, System.getProperty("user.dir")));
+		} catch(CoreException e){
+			textPerfEngOutputDir.setText(System.getProperty("user.dir"));
+		}
+
+		try{
+			textPerfEngPropFile.setText(configuration.getAttribute(MessageStrings.LINE_PROP_FILE, System.getProperty("user.dir")+"LINE.properties"));
+		} catch(CoreException e){
+			textPerfEngPropFile.setText(System.getProperty("user.dir")+"LINE.properties");
+		}
+
 		try{
 			lqnsConfigPragma.setText(configuration.getAttribute(MessageStrings.PRAGMAS, ""));
 		} catch(CoreException e){
 			lqnsConfigPragma.setText("");
 		}
-		
+
 		try{
 			lqsimConfig1.setText(configuration.getAttribute(MessageStrings.RUN_TIME, ""));
 		} catch(CoreException e){
@@ -540,7 +744,7 @@
 		} catch(CoreException e){
 			textLqsimOutputDir.setText(System.getProperty("user.dir"));
 		}
-		
+
 		try {
 			this.checkboxUseExpressionAsInput.setSelection(configuration.getAttribute(
 					MessageStrings.SRE_IS_USE_INPUT_MODEL, false));
@@ -554,18 +758,24 @@
 			this.lqnsConfigStopOnMessageLoss.setSelection(true);
 		}
 		try {
+			this.debugButton.setSelection(configuration.getAttribute(
+					MessageStrings.DEBUG_LINE, true));
+		} catch (CoreException e) {
+			this.debugButton.setSelection(true);
+		}
+		try {
 			this.lqsimConfigStopOnMessageLoss.setSelection(configuration.getAttribute(
 					MessageStrings.STOP_ON_MESSAGE_LOSS_LQSIM, true));
 		} catch (CoreException e) {
 			this.lqsimConfigStopOnMessageLoss.setSelection(true);
 		}
-		
+
 		try{
 			lqnsimConfigPragma.setText(configuration.getAttribute(MessageStrings.PRAGMAS, ""));
 		} catch(CoreException e){
 			lqnsimConfigPragma.setText("");
 		}
-		
+
 		try {
 			this.lqnsConfigInfTaskMult.setSelection(configuration.getAttribute(
 					MessageStrings.INFINITE_TASK_MULTIPLICITY, true));
@@ -576,6 +786,11 @@
 		updateLaunchConfigurationDialog();
 	}
 
+	/**
+	 * Sets the visible configuration options.
+	 *
+	 * @param solverStr the new visible configuration options
+	 */
 	private void setVisibleConfigurationOptions(String solverStr) {
 		if (solverStr.equals("SRES (Stochastic Regular Expression Solver)"))
 			stackLayout.topControl = sresConfigGroup;
@@ -583,10 +798,15 @@
 			stackLayout.topControl = lqnsConfigGroup;
 		else if (solverStr.equals("LQSIM (Layered Queueing Simulation)"))
 			stackLayout.topControl = lqsimConfigGroup;
-		
+		else if (solverStr.equals(MessageStrings.PERFENGINE_SOLVER))
+			stackLayout.topControl = perfengineConfigGroup;
+
 		lqsimConfigGroup.getParent().layout();
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.FileNamesInputTab#performApply(org.eclipse.debug.core.ILaunchConfigurationWorkingCopy)
+	 */
 	@Override
 	public void performApply(ILaunchConfigurationWorkingCopy configuration) {
 		configuration.setAttribute(MessageStrings.SOLVER, comboSolver.getText());
@@ -599,112 +819,177 @@
 		configuration.setAttribute(MessageStrings.UNDER_COEFF, lqnsConfig4.getText());
 		configuration.setAttribute(MessageStrings.LQNS_OUTPUT, comboLqnsOutput.getText());
 		configuration.setAttribute(MessageStrings.LQSIM_OUTPUT, comboLqsimOutput.getText());
-		
+
 		configuration.setAttribute(MessageStrings.STOP_ON_MESSAGE_LOSS_LQNS, lqnsConfigStopOnMessageLoss.getSelection());
 		configuration.setAttribute(MessageStrings.STOP_ON_MESSAGE_LOSS_LQSIM, lqsimConfigStopOnMessageLoss.getSelection());
+		configuration.setAttribute(MessageStrings.DEBUG_LINE, debugButton.getSelection());
 
 		configuration.setAttribute(MessageStrings.INFINITE_TASK_MULTIPLICITY, lqnsConfigInfTaskMult.getSelection());
-		
+
 		configuration.setAttribute(MessageStrings.RUN_TIME, lqsimConfig1.getText());
 		configuration.setAttribute(MessageStrings.BLOCKS, lqsimConfig2.getText());
 		configuration.setAttribute(MessageStrings.PS_QUANTUM, lqsimConfig3.getText());
-		
+
 		configuration.setAttribute(MessageStrings.PRAGMAS, lqnsimConfigPragma.getText());
 		configuration.setAttribute(MessageStrings.PRAGMAS, lqnsConfigPragma.getText());
-		
+
+		configuration.setAttribute(MessageStrings.LINE_OUT_DIR, textPerfEngOutputDir.getText());
+		configuration.setAttribute(MessageStrings.LINE_PROP_FILE, textPerfEngPropFile.getText());
 		configuration.setAttribute(MessageStrings.LQNS_OUTPUT_DIR, textLqnsOutputDir.getText());
 		configuration.setAttribute(MessageStrings.LQSIM_OUTPUT_DIR, textLqsimOutputDir.getText());
 		configuration.setAttribute(MessageStrings.SRE_OUTPUT_FILE, textSREOutputFile.getText());
-		
+
 		configuration.setAttribute(MessageStrings.SRE_IS_USE_INPUT_MODEL, checkboxUseExpressionAsInput.getSelection());
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.FileNamesInputTab#setDefaults(org.eclipse.debug.core.ILaunchConfigurationWorkingCopy)
+	 */
 	@Override
 	public void setDefaults(ILaunchConfigurationWorkingCopy configuration) {
 		// TODO Auto-generated method stub
 
 	}
-	
+
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.FileNamesInputTab#isValid(org.eclipse.debug.core.ILaunchConfiguration)
+	 */
 	@Override
 	public boolean isValid(ILaunchConfiguration launchConfig) {
-	    setErrorMessage(null);
-	    
-	    String sampDist = textSamplingDist.getText();
-	    if (sampDist.equals("")){
-	    	setErrorMessage("Sampling distance is missing!");
-	    	return false;
-	    }
-	    try {	
-	    	Double.parseDouble(sampDist);
-	    } catch (NumberFormatException e){
-	    	setErrorMessage("Sampling distance is not a Double Value!");
-	    	return false;
-	    }
-	    
-	    String maxDom = textMaxDomain.getText();
-	    if (maxDom.equals("")){
-	    	setErrorMessage("Maximum domain size is missing!");
-	    	return false;
-	    }
-	    try {	
-	    	Integer.parseInt(maxDom);
-	    } catch (NumberFormatException e){
-	    	setErrorMessage("Maximum domain is not an Integer Value!");
-	    	return false;
-	    }
-	    
-	    String outputDir = textLqnsOutputDir.getText();
-	    if(outputDir.equals("")){
-	    	setErrorMessage("Output folder must be set!");
-	    	return false;
-	    }
-	    if (outputDir.contains(" ")){
-	    	setErrorMessage("Output folder must not contain a space character, as the LQN solvers cannot handle that.");
-	    	return false;
-	    }
-	    return true;
+		setErrorMessage(null);
+
+		String sampDist = textSamplingDist.getText();
+		if (sampDist.equals("")){
+			setErrorMessage("Sampling distance is missing!");
+			return false;
+		}
+		try {	
+			Double.parseDouble(sampDist);
+		} catch (NumberFormatException e){
+			setErrorMessage("Sampling distance is not a Double Value!");
+			return false;
+		}
+
+		String maxDom = textMaxDomain.getText();
+		if (maxDom.equals("")){
+			setErrorMessage("Maximum domain size is missing!");
+			return false;
+		}
+		try {	
+			Integer.parseInt(maxDom);
+		} catch (NumberFormatException e){
+			setErrorMessage("Maximum domain is not an Integer Value!");
+			return false;
+		}
+
+		String outputDir = textLqnsOutputDir.getText();
+		if(outputDir.equals("")){
+			setErrorMessage("Output folder must be set!");
+			return false;
+		}
+		if (outputDir.contains(" ")){
+			setErrorMessage("Output folder must not contain a space character, as the LQN solvers cannot handle that.");
+			return false;
+		}
+		return true;
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.ProtocomFileNamesInputTab#activated(org.eclipse.debug.core.ILaunchConfigurationWorkingCopy)
+	 */
 	@Override
 	public void activated(ILaunchConfigurationWorkingCopy workingCopy) {
 		// Leave this method empty to prevent unnecessary invocation of
 		// initializeFrom() and multiple resulting invocations of
 		// performApply().
-}
+	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.pcm.runconfig.ProtocomFileNamesInputTab#deactivated(org.eclipse.debug.core.ILaunchConfigurationWorkingCopy)
+	 */
 	@Override
 	public void deactivated(ILaunchConfigurationWorkingCopy workingCopy) {}
-	
+
+	/**
+	 * The Class FileSystemButtonSelectionAdapter.
+	 */
 	class FileSystemButtonSelectionAdapter extends SelectionAdapter {
-		
+
+		/** The field. */
 		private Text field;
-		
+
+		/**
+		 * Instantiates a new file system button selection adapter.
+		 *
+		 * @param field the field
+		 */
 		public FileSystemButtonSelectionAdapter(Text field){
 			this.field = field;
 		}
-		
+
 		/* (non-Javadoc)
 		 * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)
 		 */
 		@Override
 		public void widgetSelected(SelectionEvent e) {
-			String resultOpenFolderDialog = openFileSystemFolderDialog();
-			if (!resultOpenFolderDialog.equals(new String(""))) {
-				field.setText(resultOpenFolderDialog);			
+			String resultOpenFileDialog = openFileSystemFileDialog();
+			if (!resultOpenFileDialog.equals(new String(""))) {
+				field.setText(resultOpenFileDialog);			
 			}
 		}
 	}
 
+	/**
+	 * The Class FileSystemFileButtonSelectionAdapter.
+	 */
+	class FileSystemFileButtonSelectionAdapter extends SelectionAdapter {
 
-	/** Button SelectionListener - call a WorkspaceResourceDialog */
+		/** The field. */
+		private Text field;
+
+		/**
+		 * Instantiates a new file system button selection adapter.
+		 *
+		 * @param field the field
+		 */
+		public FileSystemFileButtonSelectionAdapter(Text field){
+			this.field = field;
+		}
+
+		/* (non-Javadoc)
+		 * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)
+		 */
+		@Override
+		public void widgetSelected(SelectionEvent e) {
+			String resultOpenFileDialog = openFileSystemFileDialog();
+			if (!resultOpenFileDialog.equals(new String(""))) {
+				field.setText(resultOpenFileDialog);			
+			}
+		}
+	}
+
+	/**
+	 * Button SelectionListener - call a WorkspaceResourceDialog.
+	 *
+	 * @see WorkspaceButtonSelectionEvent
+	 */
 	class WorkspaceButtonSelectionListener extends SelectionAdapter {
 
+		/** The field. */
 		private Text field;
 
+		/**
+		 * Instantiates a new workspace button selection listener.
+		 *
+		 * @param field the field
+		 */
 		public WorkspaceButtonSelectionListener(Text field) {
 			this.field = field;
 		}
 
+		/* (non-Javadoc)
+		 * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)
+		 */
 		@Override
 		public void widgetSelected(SelectionEvent e) {
 			String resultOpenFolderDialog = openWorkspaceResourceFolderDialog();
@@ -714,31 +999,104 @@
 		}
 	}
 	
+	class WorkspaceFileButtonSelectionListener extends SelectionAdapter {
+
+		/** The field. */
+		private Text field;
+
+		/**
+		 * Instantiates a new workspace button selection listener.
+		 *
+		 * @param field the field
+		 */
+		public WorkspaceFileButtonSelectionListener(Text field) {
+			this.field = field;
+		}
+
+		/* (non-Javadoc)
+		 * @see org.eclipse.swt.events.SelectionAdapter#widgetSelected(org.eclipse.swt.events.SelectionEvent)
+		 */
+		@Override
+		public void widgetSelected(SelectionEvent e) {
+			String resultOpenFileDialog = openWorkspaceResourceFileDialog();
+			if (!resultOpenFileDialog.equals(new String(""))) {
+				field.setText(resultOpenFileDialog);			
+			}
+		}
+	}
+
+	/**
+	 * Open file system folder dialog.
+	 *
+	 * @return the string
+	 */
 	private String openFileSystemFolderDialog(){
 		String folderName = "";
-		
+
 		DirectoryDialog dirDialog = new DirectoryDialog(getShell(), SWT.OPEN);
 		dirDialog.setText("Select a folder.");
-		
+
 		if (dirDialog.open() != null) {
 			folderName = dirDialog.getFilterPath();
-				
+
 		}	
 		return folderName;
 	}
 	
+	/**
+	 * Open file system file dialog.
+	 *
+	 * @return the string
+	 */
+	private String openFileSystemFileDialog(){
+		String fileName = "";
+		FileDialog fDialog = new FileDialog(getShell(), SWT.OPEN);		
+		fDialog.setText("Select a file.");
+
+		if (fDialog.open() != null) {
+			fileName = fDialog.getFilterPath()+System.getProperty("file.separator")+fDialog.getFileName();
+
+		}	
+		return fileName;
+	}
+
+	/**
+	 * Open workspace resource folder dialog.
+	 *
+	 * @return the string
+	 */
 	private String openWorkspaceResourceFolderDialog(){
 		String msg = "Select a folder.";
-		
+
 		IContainer container = null;
 		IContainer[] containers = WorkspaceResourceDialog.openFolderSelection(getShell(), 
 				null, msg, false, null, new ArrayList<ViewerFilter>());
-		
+
 		if (containers.length != 0)
 			container = containers[0];
 		if (container != null)
 			return container.getLocation().toOSString();
-		
+
+		return "";
+	}
+	
+	/**
+	 * Open workspace resource folder dialog.
+	 *
+	 * @return the string
+	 */
+	private String openWorkspaceResourceFileDialog(){
+		String msg = "Select a file.";
+
+		IFile file = null;
+		IFile[] files = WorkspaceResourceDialog.openFileSelection(getShell(), 
+				null, msg, false, null, new ArrayList<ViewerFilter>());
+
+		if (files.length != 0)
+			file = files[0];
+		if (file != null)
+			return file.getLocation().toOSString();
+
 		return "";
 	}
 }
Index: src/de/uka/ipd/sdq/pcmsolver/runconfig/MessageStrings.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/runconfig/MessageStrings.java	(revision 26823)
+++ src/de/uka/ipd/sdq/pcmsolver/runconfig/MessageStrings.java	(working copy)
@@ -1,68 +1,153 @@
+/*
+ * 
+ */
 package de.uka.ipd.sdq.pcmsolver.runconfig;
 
+// TODO: Auto-generated Javadoc
+/**
+ * The Class MessageStrings.
+ */
 public class MessageStrings {
 
+	/** The Constant SRE_SOLVER. */
 	public static final String SRE_SOLVER = "SRES (Stochastic Regular Expression Solver)";
+	
+	/** The Constant LQNS_SOLVER. */
 	public static final String LQNS_SOLVER = "LQNS (Layered Queueing Network Solver)";
+	
+	/** The Constant LQSIM_SOLVER. */
 	public static final String LQSIM_SOLVER = "LQSIM (Layered Queueing Simulation)";
 
 	//public static final String VERBOSE_LOGGING = "verboseLogging";
+	/** The Constant MARKOV_STATISTICS. */
 	public static final String MARKOV_STATISTICS = "markovStatistics";
+	
+	/** The Constant SINGLE_RESULTS. */
 	public static final String SINGLE_RESULTS = "singleResults";
 
+	/** The Constant LQN_OUTPUT_HTML. */
 	public static final String LQN_OUTPUT_HTML = "HTML Output";
+	
+	/** The Constant LQN_OUTPUT_HUMAN. */
 	public static final String LQN_OUTPUT_HUMAN = "Human Readable Output";
+	
+	/** The Constant LQN_OUTPUT_XML. */
 	public static final String LQN_OUTPUT_XML = "XML Output";
 
+	/** The Constant SOLVER. */
 	public static final String SOLVER = "solver";
+	
+	/** The Constant SAMPLING_DIST. */
 	public static final String SAMPLING_DIST = "samplingDist";
+	
+	/** The Constant MAX_DOMAIN. */
 	public static final String MAX_DOMAIN = "maxDomain";
+	
+	/** The Constant SRE_IS_USE_INPUT_MODEL. */
 	public static final String SRE_IS_USE_INPUT_MODEL = "SREUseInputModel";
 
+	/** The Constant CONV_VALUE. */
 	public static final String CONV_VALUE = "convValue";
+	
+	/** The Constant IT_LIMIT. */
 	public static final String IT_LIMIT = "itLimit";
+	
+	/** The Constant PRINT_INT. */
 	public static final String PRINT_INT = "printInt";
+	
+	/** The Constant UNDER_COEFF. */
 	public static final String UNDER_COEFF = "underCoeff";
+	
+	/** The Constant LQNS_OUTPUT. */
 	public static final String LQNS_OUTPUT = "output";
+	
+	/** The Constant LQSIM_OUTPUT. */
 	public static final String LQSIM_OUTPUT = "lqsimoutput";
 	
+	/** The Constant PRAGMAS. */
 	public static final String PRAGMAS = "lqnPragmas";
 
+	/** The Constant RUN_TIME. */
 	public static final String RUN_TIME = "runTime";
+	
+	/** The Constant BLOCKS. */
 	public static final String BLOCKS = "blocks";
+	
+	/** The Constant PS_QUANTUM. */
 	public static final String PS_QUANTUM = "psQuantum";
 
+	/** The Constant STOP_ON_MESSAGE_LOSS_LQNS. */
 	public static final String STOP_ON_MESSAGE_LOSS_LQNS = "LQNS Stop On Message Loss";
+	
+	/** The Constant STOP_ON_MESSAGE_LOSS_LQSIM. */
 	public static final String STOP_ON_MESSAGE_LOSS_LQSIM = "LQSIM Stop On Message Loss";
 
+	/** The Constant LQNS_OUTPUT_DIR. */
 	public static final String LQNS_OUTPUT_DIR = "lqnsOutputDir";
+	
+	/** The Constant LQSIM_OUTPUT_DIR. */
 	public static final String LQSIM_OUTPUT_DIR = "lqsimOutputDir";
+	
+	/** The Constant SRE_OUTPUT_FILE. */
 	public static final String SRE_OUTPUT_FILE = "SREOutputDir";
 
+	/** The Constant NUMBER_OF_EVALUATED_SYSTEM_STATES_ENABLED. */
 	public static final String NUMBER_OF_EVALUATED_SYSTEM_STATES_ENABLED = "numberOfEvaluatedSystemStatesEnabled";
+	
+	/** The Constant NUMBER_OF_EVALUATED_SYSTEM_STATES. */
 	public static final String NUMBER_OF_EVALUATED_SYSTEM_STATES = "numberOfEvaluatedSystemStates";
 
+	/** The Constant NUMBER_OF_EXACT_DECIMAL_PLACES_ENABLED. */
 	public static final String NUMBER_OF_EXACT_DECIMAL_PLACES_ENABLED = "numberOfExactDecimalPlacesEnabled";
+	
+	/** The Constant NUMBER_OF_EXACT_DECIMAL_PLACES. */
 	public static final String NUMBER_OF_EXACT_DECIMAL_PLACES = "numberOfExactDecimalPlaces";
 
+	/** The Constant SOLVING_TIME_LIMIT_ENABLED. */
 	public static final String SOLVING_TIME_LIMIT_ENABLED = "solvingTimeLimitEnabled";
+	
+	/** The Constant SOLVING_TIME_LIMIT. */
 	public static final String SOLVING_TIME_LIMIT = "solvingTimeLimit";
 
+	/** The Constant LOG_FILE. */
 	public static final String LOG_FILE = "logFile";
 
+	/** The Constant MARKOV_MODEL_REDUCTION_ENABLED. */
 	public static final String MARKOV_MODEL_REDUCTION_ENABLED = "markovModelReduction";	// "optimize" option
 
+	/** The Constant MARKOV_MODEL_TRACES_ENABLED. */
 	public static final String MARKOV_MODEL_TRACES_ENABLED = "markovModelTracesEnabled";
 
+	/** The Constant ITERATION_OVER_PHYSICAL_SYSTEM_STATES_ENABLED. */
 	public static final String ITERATION_OVER_PHYSICAL_SYSTEM_STATES_ENABLED = "iterationOverPhysicalSystemStatesEnabled";
 
+	/** The Constant MARKOV_MODEL_STORAGE_ENABLED. */
 	public static final String MARKOV_MODEL_STORAGE_ENABLED = "markovModelStorageEnabled";
+	
+	/** The Constant MARKOV_MODEL_FILE. */
 	public static final String MARKOV_MODEL_FILE = "markovModelFile";
 
+	/** The Constant MARKOV_EVALUATION_MODE. */
 	public static final String MARKOV_EVALUATION_MODE = "markovEvaluationMode";
+	
+	/** The Constant INFINITE_TASK_MULTIPLICITY. */
 	public static final String INFINITE_TASK_MULTIPLICITY = "infiniteTaskMultiplicity";
 	
+	/** The Constant SAVE_RESULTS_TO_FILE_ENABLED. */
 	public static final String SAVE_RESULTS_TO_FILE_ENABLED = "saveResultsToFileEnabled";
+	
+	/** The Constant SAVE_FILE_DEFAULT. */
 	public static final String SAVE_FILE_DEFAULT = "saveFileDefault";
 
+	public static final String SHOW_HTML_RESULT = "showHtmlResult";
+
+	public static final String PERFENGINE_SOLVER = "LINE";
+
+	public static final String DEBUG_LINE = "PerfEngineDebug";
+
+	public static final String LINE_OUT_DIR = "perfengOutputDir";
+	
+	public static final String LINE_PROP_FILE = "perfEngPropFile";
+	
+
 }
Index: src/de/uka/ipd/sdq/pcmsolver/runconfig/PCMSolverConfigurationBasedConfigBuilder.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/runconfig/PCMSolverConfigurationBasedConfigBuilder.java	(revision 26823)
+++ src/de/uka/ipd/sdq/pcmsolver/runconfig/PCMSolverConfigurationBasedConfigBuilder.java	(working copy)
@@ -1,3 +1,6 @@
+/*
+ * 
+ */
 package de.uka.ipd.sdq.pcmsolver.runconfig;
 
 import org.eclipse.core.runtime.CoreException;
@@ -7,6 +10,7 @@
 import de.uka.ipd.sdq.workflow.launchconfig.AbstractWorkflowConfigurationBuilder;
 import de.uka.ipd.sdq.workflow.launchconfig.tabs.DebugEnabledCommonTab;
 
+// TODO: Auto-generated Javadoc
 /**
  * This class can build PCM solver specific configuration objects out of a given
  * Eclipse Launch Configuration.
@@ -76,11 +80,15 @@
 		config.setSolver(hasAttribute(MessageStrings.SOLVER) ? getStringAttribute(MessageStrings.SOLVER)
 				: MessageStrings.SRE_SOLVER);
 
-		// Set further properties which are specific for the LQN Solver:
+		// Set further properties which are specific for the LQN Solver and the performance engine:
 		config.setLqnsOutput(hasAttribute(MessageStrings.LQNS_OUTPUT) ? getStringAttribute(MessageStrings.LQNS_OUTPUT)
 				: MessageStrings.LQN_OUTPUT_HUMAN);
 		config.setLqnsOutputDir(hasAttribute(MessageStrings.LQNS_OUTPUT_DIR) ? getStringAttribute(MessageStrings.LQNS_OUTPUT_DIR)
 				: System.getProperty("user.dir"));
+		config.setLINEOutputDir(hasAttribute(MessageStrings.LINE_OUT_DIR) ? getStringAttribute(MessageStrings.LINE_OUT_DIR)
+				: System.getProperty("user.dir"));
+		config.setLINEPropFile(hasAttribute(MessageStrings.LINE_PROP_FILE) ? getStringAttribute(MessageStrings.LINE_PROP_FILE)
+				: System.getProperty("user.dir")+System.getProperty("file.separator")+"LINE.properties");
 		config.setLqsimOutput(hasAttribute(MessageStrings.LQSIM_OUTPUT) ? getStringAttribute(MessageStrings.LQSIM_OUTPUT)
 				: MessageStrings.LQN_OUTPUT_HUMAN);
 		config.setLqsimOutputDir(hasAttribute(MessageStrings.LQSIM_OUTPUT_DIR) ? getStringAttribute(MessageStrings.LQSIM_OUTPUT_DIR)
@@ -118,6 +126,13 @@
 		config.setStopOnMessageLossLQNS(hasAttribute(MessageStrings.STOP_ON_MESSAGE_LOSS_LQNS) 
 				? getBooleanAttribute(MessageStrings.STOP_ON_MESSAGE_LOSS_LQNS)
 				: true);
+		
+		
+		
+		config.setDebugLINE(hasAttribute(MessageStrings.DEBUG_LINE) 
+				? getBooleanAttribute(MessageStrings.DEBUG_LINE)
+				: false);
+		
 		config.setStopOnMessageLossLQSim(hasAttribute(MessageStrings.STOP_ON_MESSAGE_LOSS_LQSIM) 
 				? getBooleanAttribute(MessageStrings.STOP_ON_MESSAGE_LOSS_LQSIM)
 				: true);
@@ -125,5 +140,9 @@
 		config.setInfiniteTaskMultiplicity(hasAttribute(MessageStrings.INFINITE_TASK_MULTIPLICITY) 
 				? getBooleanAttribute(MessageStrings.INFINITE_TASK_MULTIPLICITY)
 				: true);
+				
+		config.setShowHtmlResults(hasAttribute(MessageStrings.SHOW_HTML_RESULT)? 
+				getBooleanAttribute(MessageStrings.SHOW_HTML_RESULT):
+				true);
 	}
 }
Index: src/de/uka/ipd/sdq/pcmsolver/runconfig/PCMSolverWorkflowRunConfiguration.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/runconfig/PCMSolverWorkflowRunConfiguration.java	(revision 26823)
+++ src/de/uka/ipd/sdq/pcmsolver/runconfig/PCMSolverWorkflowRunConfiguration.java	(working copy)
@@ -1,466 +1,1048 @@
+/*
+ * 
+ */
 package de.uka.ipd.sdq.pcmsolver.runconfig;
 
 import de.uka.ipd.sdq.workflow.pcm.configurations.AbstractCodeGenerationWorkflowRunConfiguration;
 
+// TODO: Auto-generated Javadoc
+/**
+ * The Class PCMSolverWorkflowRunConfiguration.
+ */
 public class PCMSolverWorkflowRunConfiguration extends
 		AbstractCodeGenerationWorkflowRunConfiguration {
 
+	/** The conv value. */
 	private String convValue;
 
+	/** The debug level. */
 	private int debugLevel;
+	
+	/** The distance. */
 	private double distance;
+	
+	/** The domain size. */
 	private int domainSize;
 
+	/** The is reliability analysis. */
 	private boolean isReliabilityAnalysis;
 
+	/** The is use sre input model. */
 	private boolean isUseSREInputModel;
+	
+	/** The iteration over physical system states enabled. */
 	private boolean iterationOverPhysicalSystemStatesEnabled;
 
+	/** The it limit. */
 	private String itLimit;
+	
+	/** The log file. */
 	private String logFile;
+	
+	/** The lqns output. */
 	private String lqnsOutput;
+	
+	/** The lqns output dir. */
 	private String lqnsOutputDir;
+	
+	/** The LINE output dir. */
+	private String LINEOutputDir;
+	
+	/** The LINE properties file. */
+	private String LINEPropFile;
 
+	/** The lqsim blocks. */
 	private String lqsimBlocks;
+	
+	/** The lqsim output. */
 	private String lqsimOutput;
+	
+	/** The lqsim output dir. */
 	private String lqsimOutputDir;
+	
+	/** The lqsim runtime. */
 	private String lqsimRuntime;
+	
+	/** The markov evaluation mode. */
 	private String markovEvaluationMode;
+	
+	/** The markov model file. */
 	private String markovModelFile;
+	
+	/** The markov model reduction enabled. */
 	private boolean markovModelReductionEnabled;
+	
+	/** The markov model storage enabled. */
 	private boolean markovModelStorageEnabled;
 
+	/** The markov model traces enabled. */
 	private boolean markovModelTracesEnabled;
+	
+	/** The max real runtime sec. */
 	private Integer maxRealRuntimeSec = null;
+	
+	/** The number of evaluated system states. */
 	private long numberOfEvaluatedSystemStates;
+	
+	/** The number of evaluated system states enabled. */
 	private boolean numberOfEvaluatedSystemStatesEnabled;
 
+	/** The number of exact decimal places. */
 	private int numberOfExactDecimalPlaces;
+	
+	/** The number of exact decimal places enabled. */
 	private boolean numberOfExactDecimalPlacesEnabled;
 
+	/** The output filename. */
 	private String outputFilename;
 
+	/** The print int. */
 	private String printInt;
 
+	/** The print markov single results. */
 	private boolean printMarkovSingleResults;
+	
+	/** The print markov statistics. */
 	private boolean printMarkovStatistics;
 	
+	/** The sensitivity model enabled. */
 	private boolean sensitivityModelEnabled;
+	
+	/** The sensitivity model file name. */
 	private String sensitivityModelFileName;
+	
+	/** The sensitivity log file name. */
 	private String sensitivityLogFileName;
 
+	/** The ps quantum. */
 	private String psQuantum;
 
+	/** The solver. */
 	private String solver;
 
+	/** The solving time limit. */
 	private long solvingTimeLimit;
 
+	/** The solving time limit enabled. */
 	private boolean solvingTimeLimitEnabled;
 
+	/** The sre output file. */
 	private String sreOutputFile;
 
+	/** The stop on message loss lqns. */
 	private boolean stopOnMessageLossLQNS;
+	
+	/** The stop on message loss lqns. */
+	private boolean debugLINEine;
+	
+	/** The stop on message loss lq sim. */
 	private boolean stopOnMessageLossLQSim;
 
+	/** The is infinite task multiplicity. */
 	private boolean isInfiniteTaskMultiplicity;
 
+	/** The save file. */
 	private String saveFile;
+	
+	/** The save results to file enabled. */
 	private boolean saveResultsToFileEnabled;
+	
+	/** The is show html results. */
 	private boolean isShowHtmlResults = true;
-
-	public boolean isInfiniteTaskMultiplicity() {
-		return isInfiniteTaskMultiplicity;
-	}
-
-	public void setInfiniteTaskMultiplicity(boolean isInfiniteTaskMultiplicity) {
-		this.isInfiniteTaskMultiplicity = isInfiniteTaskMultiplicity;
-	}
+	
 
+	
+	/** The under coeff. */
 	private String underCoeff;
 
+	/** The lqn pragmas. */
 	private String lqnPragmas;
 
+	/**
+	 * Instantiates a new pCM solver workflow run configuration.
+	 */
 	public PCMSolverWorkflowRunConfiguration() {
 		super();
 	}
 
+	/**
+	 * Gets the conv value.
+	 *
+	 * @return the conv value
+	 */
 	public String getConvValue() {
 		return convValue;
 	}
 
+	/**
+	 * Gets the debug level.
+	 *
+	 * @return the debug level
+	 */
 	public int getDebugLevel() {
 		return debugLevel;
 	}
 
+	/**
+	 * Gets the stop on message loss lqns.
+	 *
+	 * @return the stop on message loss lqns
+	 */
+	public boolean getDebugLINE() {
+		return this.debugLINEine;
+	}
+
+	/**
+	 * Gets the distance.
+	 *
+	 * @return the distance
+	 */
 	public double getDistance() {
 		return distance;
 	}
 
+	/**
+	 * Gets the domain size.
+	 *
+	 * @return the domain size
+	 */
 	public int getDomainSize() {
 		return domainSize;
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.AbstractJobConfiguration#getErrorMessage()
+	 */
 	@Override
 	public String getErrorMessage() {
 		// TODO Auto-generated method stub
 		return null;
 	}
 
+	/**
+	 * Gets the it limit.
+	 *
+	 * @return the it limit
+	 */
 	public String getItLimit() {
 		return itLimit;
 	}
 
+	/**
+	 * Gets the log file.
+	 *
+	 * @return the log file
+	 */
 	public String getLogFile() {
 		return logFile;
 	}
 
 	/**
-	 * LQN output type. Uses constants {@link MessageStrings.LQN_OUTPUT_HTML} etc. 
-	 * @return
+	 * LQN output type. Uses constants {@link MessageStrings.LQN_OUTPUT_HTML} etc.
+	 *
+	 * @return the lqns output
 	 */
 	public String getLqnsOutput() {
 		return lqnsOutput;
 	}
 
+	/**
+	 * Gets the lqns output dir.
+	 *
+	 * @return the lqns output dir
+	 */
 	public String getLqnsOutputDir() {
 		return lqnsOutputDir;
 	}
 
+	/**
+	 * Gets the lQ sim blocks.
+	 *
+	 * @return the lQ sim blocks
+	 */
 	public String getLQSimBlocks() {
 		return this.lqsimBlocks;
 	}
-
+	
+	
+	/**
+	 * Gets the lqsim output.
+	 *
+	 * @return the lqsim output
+	 */
 	public String getLqsimOutput() {
 		return lqsimOutput;
 	}
 
+	/**
+	 * Gets the lqsim output dir.
+	 *
+	 * @return the lqsim output dir
+	 */
 	public String getLqsimOutputDir() {
 		return lqsimOutputDir;
 	}
 
+	/**
+	 * Gets the lQ sim runtime.
+	 *
+	 * @return the lQ sim runtime
+	 */
 	public String getLQSimRuntime() {
 		return this.lqsimRuntime;
 	}
 
+	/**
+	 * Gets the markov evaluation mode.
+	 *
+	 * @return the markov evaluation mode
+	 */
 	public String getMarkovEvaluationMode() {
 		return markovEvaluationMode;
 	}
 
+	/**
+	 * Gets the markov model file.
+	 *
+	 * @return the markov model file
+	 */
 	public String getMarkovModelFile() {
 		return markovModelFile;
 	}
 
+	/**
+	 * Gets the max real runtime sec.
+	 *
+	 * @return the max real runtime sec
+	 */
 	public Integer getMaxRealRuntimeSec() {
 		return maxRealRuntimeSec;
 	}
 
+	/**
+	 * Gets the number of evaluated system states.
+	 *
+	 * @return the number of evaluated system states
+	 */
 	public long getNumberOfEvaluatedSystemStates() {
 		return numberOfEvaluatedSystemStates;
 	}
 
+	/**
+	 * Gets the number of exact decimal places.
+	 *
+	 * @return the number of exact decimal places
+	 */
 	public int getNumberOfExactDecimalPlaces() {
 		return numberOfExactDecimalPlaces;
 	}
 
+	/**
+	 * Gets the output filename.
+	 *
+	 * @return the output filename
+	 */
 	public String getOutputFilename() {
 		return outputFilename;
 	}
 
+	/**
+	 * Gets the lqns output dir.
+	 *
+	 * @return the lqns output dir
+	 */
+	public String getLINEOutputDir() {
+		return LINEOutputDir;
+	}
+
+	public String getLINEPropFile() {
+		return LINEPropFile;
+	}
+
+	/**
+	 * Gets the pragmas.
+	 *
+	 * @return the pragmas
+	 */
+	public String getPragmas() {
+		return this.lqnPragmas;
+	}
+
+	/**
+	 * Gets the prints the int.
+	 *
+	 * @return the prints the int
+	 */
 	public String getPrintInt() {
 		return printInt;
 	}
 
+	/**
+	 * Gets the ps quantum.
+	 *
+	 * @return the ps quantum
+	 */
 	public String getPsQuantum() {
 		return psQuantum;
 	}
 
+	/**
+	 * Gets the save file.
+	 *
+	 * @return the save file
+	 */
+	public String getSaveFile() {
+		return saveFile;
+	}
+
+	/**
+	 * Gets the sensitivity log file name.
+	 *
+	 * @return the sensitivity log file name
+	 */
+	public String getSensitivityLogFileName() {
+		return sensitivityLogFileName;
+	}
+
+	/**
+	 * Gets the sensitivity model file name.
+	 *
+	 * @return the sensitivity model file name
+	 */
+	public String getSensitivityModelFileName() {
+		return sensitivityModelFileName;
+	}
+	
+	/**
+	 * Gets the solver.
+	 *
+	 * @return the solver
+	 */
 	public String getSolver() {
 		return solver;
 	}
 
+	/**
+	 * Gets the solving time limit.
+	 *
+	 * @return the solving time limit
+	 */
 	public long getSolvingTimeLimit() {
 		return solvingTimeLimit;
 	}
 
+	/**
+	 * Gets the sRE output file.
+	 *
+	 * @return the sRE output file
+	 */
 	public String getSREOutputFile() {
 		return this.sreOutputFile;
 	}
 
+	/**
+	 * Gets the stop on message loss lqns.
+	 *
+	 * @return the stop on message loss lqns
+	 */
 	public boolean getStopOnMessageLossLQNS() {
 		return this.stopOnMessageLossLQNS;
 	}
 
+	/**
+	 * Gets the stop on message loss lq sim.
+	 *
+	 * @return the stop on message loss lq sim
+	 */
 	public boolean getStopOnMessageLossLQSim() {
 		return this.stopOnMessageLossLQSim;
 	}
 
+	/**
+	 * Gets the under coeff.
+	 *
+	 * @return the under coeff
+	 */
 	public String getUnderCoeff() {
 		return underCoeff;
 	}
 
-	public String getPragmas() {
-		return this.lqnPragmas;
+	/**
+	 * Checks if is infinite task multiplicity.
+	 *
+	 * @return true, if is infinite task multiplicity
+	 */
+	public boolean isInfiniteTaskMultiplicity() {
+		return isInfiniteTaskMultiplicity;
 	}
 
+	/**
+	 * Checks if is iteration over physical system states enabled.
+	 *
+	 * @return true, if is iteration over physical system states enabled
+	 */
 	public boolean isIterationOverPhysicalSystemStatesEnabled() {
 		return iterationOverPhysicalSystemStatesEnabled;
 	}
 
+	/**
+	 * Checks if is markov model reduction enabled.
+	 *
+	 * @return true, if is markov model reduction enabled
+	 */
 	public boolean isMarkovModelReductionEnabled() {
 		return markovModelReductionEnabled;
 	}
 
+	/**
+	 * Checks if is markov model storage enabled.
+	 *
+	 * @return true, if is markov model storage enabled
+	 */
 	public boolean isMarkovModelStorageEnabled() {
 		return markovModelStorageEnabled;
 	}
 
+	/**
+	 * Checks if is markov model traces enabled.
+	 *
+	 * @return true, if is markov model traces enabled
+	 */
 	public boolean isMarkovModelTracesEnabled() {
 		return markovModelTracesEnabled;
 	}
 
+	/**
+	 * Checks if is number of evaluated system states enabled.
+	 *
+	 * @return true, if is number of evaluated system states enabled
+	 */
 	public boolean isNumberOfEvaluatedSystemStatesEnabled() {
 		return numberOfEvaluatedSystemStatesEnabled;
 	}
 
+	/**
+	 * Checks if is number of exact decimal places enabled.
+	 *
+	 * @return true, if is number of exact decimal places enabled
+	 */
 	public boolean isNumberOfExactDecimalPlacesEnabled() {
 		return numberOfExactDecimalPlacesEnabled;
 	}
-
+	
+	/**
+	 * Checks if is prints the markov single results.
+	 *
+	 * @return true, if is prints the markov single results
+	 */
 	public boolean isPrintMarkovSingleResults() {
 		return printMarkovSingleResults;
 	}
-
+	
+	/**
+	 * Checks if is prints the markov statistics.
+	 *
+	 * @return true, if is prints the markov statistics
+	 */
 	public boolean isPrintMarkovStatistics() {
 		return printMarkovStatistics;
 	}
 
-	public boolean isSensitivityModelEnabled() {
-		return sensitivityModelEnabled;
+	/**
+	 * Checks if is reliability analysis.
+	 *
+	 * @return true, if is reliability analysis
+	 */
+	public boolean isReliabilityAnalysis() {
+		return this.isReliabilityAnalysis;
 	}
-	
-	public String getSensitivityModelFileName() {
-		return sensitivityModelFileName;
+
+	/**
+	 * Checks if is save results to file enabled.
+	 *
+	 * @return true, if is save results to file enabled
+	 */
+	public boolean isSaveResultsToFileEnabled() {
+		return saveResultsToFileEnabled;
 	}
-	
-	public String getSensitivityLogFileName() {
-		return sensitivityLogFileName;
+
+	/**
+	 * Checks if is sensitivity model enabled.
+	 *
+	 * @return true, if is sensitivity model enabled
+	 */
+	public boolean isSensitivityModelEnabled() {
+		return sensitivityModelEnabled;
 	}
 
-	public boolean isReliabilityAnalysis() {
-		return this.isReliabilityAnalysis;
+	/**
+	 * Show HTML results of reliability analysis. For HTML results of LQN solver analysis, see
+	 *
+	 * @return true, if is show html results
+	 * {@link #getLqnsOutput()}.
+	 */
+	public boolean isShowHtmlResults() {
+		return this.isShowHtmlResults;
 	}
 
+	/**
+	 * Checks if is solving time limit enabled.
+	 *
+	 * @return true, if is solving time limit enabled
+	 */
 	public boolean isSolvingTimeLimitEnabled() {
 		return solvingTimeLimitEnabled;
 	}
 
+	/**
+	 * Checks if is use sre input model.
+	 *
+	 * @return true, if is use sre input model
+	 */
 	public boolean isUseSREInputModel() {
 		return this.isUseSREInputModel;
 	}
 
+	/**
+	 * Sets the conv value.
+	 *
+	 * @param convValue the new conv value
+	 */
 	public void setConvValue(String convValue) {
 		this.convValue = convValue;
 	}
 
+	/**
+	 * Sets the debug level.
+	 *
+	 * @param debugLevel the new debug level
+	 */
 	public void setDebugLevel(int debugLevel) {
 		this.debugLevel = debugLevel;
 	}
 
+	/**
+	 * Sets the stop on message loss lqns.
+	 *
+	 * @param b the new stop on message loss lqns
+	 */
+	public void setDebugLINE(boolean b) {
+		this.debugLINEine = b;
+	}
+
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.workflow.AbstractJobConfiguration#setDefaults()
+	 */
 	@Override
 	public void setDefaults() {
 		// TODO Auto-generated method stub
 
 	}
 
+	/**
+	 * Sets the distance.
+	 *
+	 * @param distance the new distance
+	 */
 	public void setDistance(double distance) {
 		this.distance = distance;
 	}
 
+	/**
+	 * Sets the domain size.
+	 *
+	 * @param domainSize the new domain size
+	 */
 	public void setDomainSize(int domainSize) {
 		this.domainSize = domainSize;
 	}
 
+	/**
+	 * Sets the infinite task multiplicity.
+	 *
+	 * @param isInfiniteTaskMultiplicity the new infinite task multiplicity
+	 */
+	public void setInfiniteTaskMultiplicity(boolean isInfiniteTaskMultiplicity) {
+		this.isInfiniteTaskMultiplicity = isInfiniteTaskMultiplicity;
+	}
+
+	/**
+	 * Sets the checks if is use sre input model.
+	 *
+	 * @param b the new checks if is use sre input model
+	 */
 	public void setIsUseSREInputModel(boolean b) {
 		this.isUseSREInputModel = b;
 
 	}
-
+	
+	/**
+	 * Sets the iteration over physical system states enabled.
+	 *
+	 * @param iterationOverPhysicalSystemStatesEnabled the new iteration over physical system states enabled
+	 */
 	public void setIterationOverPhysicalSystemStatesEnabled(
 			boolean iterationOverPhysicalSystemStatesEnabled) {
 		this.iterationOverPhysicalSystemStatesEnabled = iterationOverPhysicalSystemStatesEnabled;
 	}
 
+	/**
+	 * Sets the it limit.
+	 *
+	 * @param itLimit the new it limit
+	 */
 	public void setItLimit(String itLimit) {
 		this.itLimit = itLimit;
 	}
 
+	/**
+	 * Sets the log file.
+	 *
+	 * @param logFile the new log file
+	 */
 	public void setLogFile(String logFile) {
 		this.logFile = logFile;
 	}
 
+	/**
+	 * Sets the lqns output.
+	 *
+	 * @param lqnsOutput the new lqns output
+	 */
 	public void setLqnsOutput(String lqnsOutput) {
 		this.lqnsOutput = lqnsOutput;
 	}
 
+	/**
+	 * Sets the lqns output dir.
+	 *
+	 * @param lqnsOutputDir the new lqns output dir
+	 */
 	public void setLqnsOutputDir(String lqnsOutputDir) {
 		this.lqnsOutputDir = lqnsOutputDir;
 	}
 
+	/**
+	 * Sets the lQ sim blocks.
+	 *
+	 * @param blocks the new lQ sim blocks
+	 */
 	public void setLQSimBlocks(String blocks) {
 		this.lqsimBlocks = blocks;
 	}
 
+	/**
+	 * Sets the lqsim output.
+	 *
+	 * @param lqsimOutput the new lqsim output
+	 */
 	public void setLqsimOutput(String lqsimOutput) {
 		this.lqsimOutput = lqsimOutput;
 	}
 
+	/**
+	 * Sets the lqsim output dir.
+	 *
+	 * @param lqsimOutputDir the new lqsim output dir
+	 */
 	public void setLqsimOutputDir(String lqsimOutputDir) {
 		this.lqsimOutputDir = lqsimOutputDir;
 	}
 
+	/**
+	 * Sets the lQ sim runtime.
+	 *
+	 * @param runtime the new lQ sim runtime
+	 */
 	public void setLQSimRuntime(String runtime) {
 		this.lqsimRuntime = runtime;
 	}
 
+	/**
+	 * Sets the markov evaluation mode.
+	 *
+	 * @param markovEvaluationMode the new markov evaluation mode
+	 */
 	public void setMarkovEvaluationMode(String markovEvaluationMode) {
 		this.markovEvaluationMode = markovEvaluationMode;
 	}
 
+	/**
+	 * Sets the markov model file.
+	 *
+	 * @param markovModelFile the new markov model file
+	 */
 	public void setMarkovModelFile(String markovModelFile) {
 		this.markovModelFile = markovModelFile;
 	}
 
+	/**
+	 * Sets the markov model reduction enabled.
+	 *
+	 * @param markovModelReductionEnabled the new markov model reduction enabled
+	 */
 	public void setMarkovModelReductionEnabled(
 			boolean markovModelReductionEnabled) {
 		this.markovModelReductionEnabled = markovModelReductionEnabled;
 	}
 
+	/**
+	 * Sets the markov model storage enabled.
+	 *
+	 * @param markovModelStorageEnabled the new markov model storage enabled
+	 */
 	public void setMarkovModelStorageEnabled(boolean markovModelStorageEnabled) {
 		this.markovModelStorageEnabled = markovModelStorageEnabled;
 	}
 
+	/**
+	 * Sets the markov model traces enabled.
+	 *
+	 * @param markovModelTracesEnabled the new markov model traces enabled
+	 */
 	public void setMarkovModelTracesEnabled(boolean markovModelTracesEnabled) {
 		this.markovModelTracesEnabled = markovModelTracesEnabled;
 	}
 
+	/**
+	 * Sets the max real runtime sec.
+	 *
+	 * @param maxRealRuntimeSec the new max real runtime sec
+	 */
 	public void setMaxRealRuntimeSec(Integer maxRealRuntimeSec) {
 		this.maxRealRuntimeSec = maxRealRuntimeSec;
 	}
 
+	/**
+	 * Sets the number of evaluated system states.
+	 *
+	 * @param numberOfEvaluatedSystemStates the new number of evaluated system states
+	 */
 	public void setNumberOfEvaluatedSystemStates(
 			long numberOfEvaluatedSystemStates) {
 		this.numberOfEvaluatedSystemStates = numberOfEvaluatedSystemStates;
 	}
 
+	/**
+	 * Sets the number of evaluated system states enabled.
+	 *
+	 * @param numberOfEvaluatedSystemStatesEnabled the new number of evaluated system states enabled
+	 */
 	public void setNumberOfEvaluatedSystemStatesEnabled(
 			boolean numberOfEvaluatedSystemStatesEnabled) {
 		this.numberOfEvaluatedSystemStatesEnabled = numberOfEvaluatedSystemStatesEnabled;
 	}
 
+	/**
+	 * Sets the number of exact decimal places.
+	 *
+	 * @param numberOfExactDecimalPlaces the new number of exact decimal places
+	 */
 	public void setNumberOfExactDecimalPlaces(int numberOfExactDecimalPlaces) {
 		this.numberOfExactDecimalPlaces = numberOfExactDecimalPlaces;
 	}
 
+	/**
+	 * Sets the number of exact decimal places enabled.
+	 *
+	 * @param numberOfExactDecimalPlacesEnabled the new number of exact decimal places enabled
+	 */
 	public void setNumberOfExactDecimalPlacesEnabled(
 			boolean numberOfExactDecimalPlacesEnabled) {
 		this.numberOfExactDecimalPlacesEnabled = numberOfExactDecimalPlacesEnabled;
 	}
 
+	/**
+	 * Sets the output filename.
+	 *
+	 * @param outputFilename the new output filename
+	 */
 	public void setOutputFilename(String outputFilename) {
 		this.outputFilename = outputFilename;
 	}
 
+	/**
+	 * Sets the lqns output dir.
+	 *
+	 * @param lqnsOutputDir the new lqns output dir
+	 */
+	public void setLINEOutputDir(String LINEOutDir) {
+		this.LINEOutputDir = LINEOutDir;
+	}
+
+	public void setLINEPropFile(String LINEPropFile) {
+		this.LINEPropFile = LINEPropFile;
+	}
+
+	/**
+	 * Sets the pragmas.
+	 *
+	 * @param pragmaString the new pragmas
+	 */
+	public void setPragmas(String pragmaString) {
+		this.lqnPragmas = pragmaString;
+	}
+
+	/**
+	 * Sets the prints the int.
+	 *
+	 * @param printInt the new prints the int
+	 */
 	public void setPrintInt(String printInt) {
 		this.printInt = printInt;
 	}
 
+	/**
+	 * Sets the prints the markov single results.
+	 *
+	 * @param printMarkovSingleResults the new prints the markov single results
+	 */
 	public void setPrintMarkovSingleResults(boolean printMarkovSingleResults) {
 		this.printMarkovSingleResults = printMarkovSingleResults;
 	}
 
+	/**
+	 * Sets the prints the markov statistics.
+	 *
+	 * @param printMarkovStatistics the new prints the markov statistics
+	 */
 	public void setPrintMarkovStatistics(boolean printMarkovStatistics) {
 		this.printMarkovStatistics = printMarkovStatistics;
 	}
 
-	public void setSensitivityModelEnabled(boolean sensitivityModelEnabled) {
-		this.sensitivityModelEnabled = sensitivityModelEnabled;
+	/**
+	 * Sets the ps quantum.
+	 *
+	 * @param psQuantum the new ps quantum
+	 */
+	public void setPsQuantum(String psQuantum) {
+		this.psQuantum = psQuantum;
 	}
 
-	public void setSensitivityModelFileName(String sensitivityModelFileName) {
-		this.sensitivityModelFileName = sensitivityModelFileName;
+	/**
+	 * Sets the reliability analysis.
+	 *
+	 * @param isReliabilityAnalysis the new reliability analysis
+	 */
+	public void setReliabilityAnalysis(boolean isReliabilityAnalysis) {
+		this.isReliabilityAnalysis = isReliabilityAnalysis;
 	}
 
+	/**
+	 * Sets the save file.
+	 *
+	 * @param saveFile the new save file
+	 */
+	public void setSaveFile(String saveFile) {
+		this.saveFile = saveFile;
+	}
+	
+	/**
+	 * Sets the save results to file enabled.
+	 *
+	 * @param saveResultsToFileEnabled the new save results to file enabled
+	 */
+	public void setSaveResultsToFileEnabled(boolean saveResultsToFileEnabled) {
+		this.saveResultsToFileEnabled = saveResultsToFileEnabled;
+	}
+
+	/**
+	 * Sets the sensitivity log file name.
+	 *
+	 * @param sensitivityLogFileName the new sensitivity log file name
+	 */
 	public void setSensitivityLogFileName(String sensitivityLogFileName) {
 		this.sensitivityLogFileName = sensitivityLogFileName;
 	}
 
-	public void setPsQuantum(String psQuantum) {
-		this.psQuantum = psQuantum;
+	/**
+	 * Sets the sensitivity model enabled.
+	 *
+	 * @param sensitivityModelEnabled the new sensitivity model enabled
+	 */
+	public void setSensitivityModelEnabled(boolean sensitivityModelEnabled) {
+		this.sensitivityModelEnabled = sensitivityModelEnabled;
 	}
 
-	public void setReliabilityAnalysis(boolean isReliabilityAnalysis) {
-		this.isReliabilityAnalysis = isReliabilityAnalysis;
+	/**
+	 * Sets the sensitivity model file name.
+	 *
+	 * @param sensitivityModelFileName the new sensitivity model file name
+	 */
+	public void setSensitivityModelFileName(String sensitivityModelFileName) {
+		this.sensitivityModelFileName = sensitivityModelFileName;
 	}
 
+	/**
+	 * Sets the show html results.
+	 *
+	 * @param isShowHtmlResults the new show html results
+	 */
+	public void setShowHtmlResults(boolean isShowHtmlResults) {
+		this.isShowHtmlResults = isShowHtmlResults;
+	}
+
+	/**
+	 * Sets the solver.
+	 *
+	 * @param solver the new solver
+	 */
 	public void setSolver(String solver) {
 		this.solver = solver;
 	}
-
+	
+	/**
+	 * Sets the solving time limit.
+	 *
+	 * @param solvingTimeLimit the new solving time limit
+	 */
 	public void setSolvingTimeLimit(long solvingTimeLimit) {
 		this.solvingTimeLimit = solvingTimeLimit;
 	}
 
+	/**
+	 * Sets the solving time limit enabled.
+	 *
+	 * @param solvingTimeLimitEnabled the new solving time limit enabled
+	 */
 	public void setSolvingTimeLimitEnabled(boolean solvingTimeLimitEnabled) {
 		this.solvingTimeLimitEnabled = solvingTimeLimitEnabled;
 	}
-
+	
+	/**
+	 * Sets the sRE output file.
+	 *
+	 * @param outputDir the new sRE output file
+	 */
 	public void setSREOutputFile(String outputDir) {
 		this.sreOutputFile = outputDir;
 	}
 
+	/**
+	 * Sets the stop on message loss lqns.
+	 *
+	 * @param b the new stop on message loss lqns
+	 */
 	public void setStopOnMessageLossLQNS(boolean b) {
 		this.stopOnMessageLossLQNS = b;
 	}
 
+	/**
+	 * Sets the stop on message loss lq sim.
+	 *
+	 * @param b the new stop on message loss lq sim
+	 */
 	public void setStopOnMessageLossLQSim(boolean b) {
 		this.stopOnMessageLossLQSim = b;
 	}
 
-	public void setUnderCoeff(String underCoeff) {
-		this.underCoeff = underCoeff;
-	}
-
-	public String getSaveFile() {
-		return saveFile;
-	}
-
-	public void setSaveFile(String saveFile) {
-		this.saveFile = saveFile;
-	}
-
-	public boolean isSaveResultsToFileEnabled() {
-		return saveResultsToFileEnabled;
-	}
-	
 	/**
-	 * Show HTML results of reliability analysis. For HTML results of LQN solver analysis, see 
-	 * {@link #getLqnsOutput()}. 
-	 * @return
+	 * Sets the under coeff.
+	 *
+	 * @param underCoeff the new under coeff
 	 */
-	public boolean isShowHtmlResults() {
-		return this.isShowHtmlResults;
-	}
-
-	public void setSaveResultsToFileEnabled(boolean saveResultsToFileEnabled) {
-		this.saveResultsToFileEnabled = saveResultsToFileEnabled;
-	}
-	
-	public void setShowHtmlResults(boolean isShowHtmlResults) {
-		this.isShowHtmlResults = isShowHtmlResults;
-	}
-
-	public void setPragmas(String pragmaString) {
-		this.lqnPragmas = pragmaString;
+	public void setUnderCoeff(String underCoeff) {
+		this.underCoeff = underCoeff;
 	}
 
 
Index: src/de/uka/ipd/sdq/pcmsolver/transformations/line/LineServerHandler.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/transformations/line/LineServerHandler.java	(revision 0)
+++ src/de/uka/ipd/sdq/pcmsolver/transformations/line/LineServerHandler.java	(revision 0)
@@ -0,0 +1,307 @@
+/*******************************************************************************
+ * Copyright 2014 Giovanni Paolo Gibilisco
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package de.uka.ipd.sdq.pcmsolver.transformations.line;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.Properties;
+
+import org.apache.log4j.Logger;
+
+public class LineServerHandler {
+	/** LINE connection handlers **/
+	private String host = null;
+	private int port=-1;
+	private Socket lineSocket = null;
+	private PrintWriter out = null;
+	private BufferedReader processIn = null;
+	private BufferedReader socketIn = null;
+	private MessageHandler processMessages;
+	private MessageHandler socketMessages;
+	private boolean localInstance = false;
+	private Process proc;
+	private File directory = null;
+	private String MCR_dir = null;
+	private String propertyFile = null;
+	private static final Logger logger = Logger.getLogger(LineServerHandler.class);
+	private final static String LINE_UNIX = "run_LINE.sh";
+	private final static String LINE_WINDOWS = "LINE";
+	
+
+	/**
+	 * Handler for all interactions with an instance of LINE
+	 * @param properyFile
+	 */
+	public LineServerHandler(String properyFile) {
+		this.propertyFile = properyFile;
+	}
+
+
+	/**
+	 * Closes the connection with the server
+	 */
+	public void closeConnections() {
+
+		//Send LINE command to close the connection
+		if(out!= null && lineSocket != null && !lineSocket.isClosed()){
+			String command = "CLOSE";
+			out.println(command);
+			out.flush();
+		}
+		if (out != null)
+			out.close();
+
+		try {
+			if (socketMessages != null && socketIn != null) {
+				socketMessages.close();
+				socketIn.close();
+				socketIn = null;
+				socketMessages = null;				
+			}
+			if (lineSocket != null){
+				lineSocket.close();
+				socketMessages = null;	
+			}
+		} catch (IOException e) {
+			logger.error("Error in closing LINE connection");
+		}
+	}
+	
+	private void loadProperties(){
+		Properties lineProperties = new Properties();
+
+		
+		try {
+			FileInputStream propInput = new FileInputStream(propertyFile);
+			lineProperties.load(propInput);
+			propInput.close();
+			if (host == null)
+				host = lineProperties.getProperty("host", "localhost");
+			if (port == -1)
+				port = Integer.parseInt(lineProperties.getProperty("port",
+						"5463"));
+			directory = new File(lineProperties.getProperty("directory", null));
+			MCR_dir = lineProperties.getProperty("MCR_dir","/usr/local/MATLAB/MATLAB_Compiler_Runtime/v81");
+		}catch(IOException e){
+			logger.error("Could not load LINE connection properties",e);
+		}
+	}
+
+	/**
+	 * Connects to LINE server, if no instance of line server is found then a new one is launched
+	 */
+	public void connectToLINEServer() {
+
+		
+		loadProperties();
+		
+		try {			
+			// try to connect
+			logger.info("connecting to LINE");
+			initLINEConnection();
+		} catch (UnknownHostException e) {
+			// fallback to local host and retry
+			if (host != "localhost") {
+				closeConnections();
+				logger.info("Don't know about host:" + host
+						+ ". Switching to localhost and trying reconnection.");
+				host = "localhost";
+				connectToLINEServer();
+			}else{
+				logger.error("Error while connecting to localhost",e);
+			}
+		} catch (IOException e) {
+			closeConnections();
+			// fall back to local host and launch LINE
+			logger.info("Could not connect to LINE on host: "
+					+ host
+					+ " on port: "
+					+ port
+					+ " trying to launch line locally and connect to localhost. This might take a while..");
+			//launch line locally
+			host = "localhost";
+			launchLine();			
+			try {
+				initLINEConnection();
+			} catch (IOException e1) {
+				closeConnections();
+				logger.error("Could not connect to local instance of LINE",e1);				
+			}
+		}
+	}
+
+	private void reConnect(){
+		try {
+			initLINEConnection();
+		} catch (IOException e) {
+			logger.error("Error in re-connecting to LINE",e);
+		}
+	}
+
+	private void initLINEConnection() throws IOException {
+		lineSocket = new Socket(host, port);
+
+		out = new PrintWriter(lineSocket.getOutputStream());
+		if (socketIn == null)
+			socketIn = new BufferedReader(new InputStreamReader(
+					lineSocket.getInputStream()));
+		if (socketMessages == null) {
+			socketMessages = new MessageHandler(socketIn, "socket");
+			(new Thread(socketMessages)).start();
+		}
+		while (!socketMessages.isConnected())
+			try {
+				Thread.sleep(100);
+			} catch (InterruptedException e) {
+				logger.error("Error while waiting for LINE connection",e);
+			}
+		logger.info("Connected to LINE on " + host + ":" + port);
+	}
+
+	/**
+	 * checks if the model submitted with the specified modelFile has been solved. 
+	 * @param modelFile
+	 * @return
+	 */
+	public boolean isSolved(String modelFile) {
+		return socketMessages.isModelEvaluated(modelFile);
+	}
+
+	
+	/**
+	 * Launches a new instance of line
+	 * @return
+	 */
+	public boolean launchLine() {
+		try {
+//			String lineInvocation = "LINE" + " " + "\""
+//					+ propFile.getAbsolutePath().replace('\\', '/') + "\"";
+			
+			String lineInvocation = /*"LINE" +*/ " " + "\""
+					+ propertyFile.replace('\\', '/') + "\"";
+			
+			if (System.getProperty("os.name").indexOf("Windows") > -1)
+				lineInvocation = LINE_WINDOWS + lineInvocation;
+			else
+				lineInvocation = LINE_UNIX+" "+MCR_dir+" "+propertyFile.replace('\\', '/');
+			
+			logger.debug(lineInvocation);
+			ProcessBuilder pb = new ProcessBuilder(lineInvocation.split("\\s"));
+			pb.directory(directory);
+			pb.redirectErrorStream(true);
+			proc = pb.start();
+			processIn = new BufferedReader(new InputStreamReader(
+					proc.getInputStream()));
+			processMessages = new MessageHandler(processIn, "process");
+			(new Thread(processMessages)).start();
+			while (!processMessages.isRunning())
+				Thread.sleep(100);
+
+			localInstance = true;
+
+			// the startup has ended
+			logger.info("Local instance of LINE launched");
+
+			return true;
+		} catch (IOException | InterruptedException e) {
+			logger.error("Error in launching LINE",e);
+			return false;
+		}
+
+	}
+
+	/**
+	 * solves a LQN model
+	 * @param modelFilePath
+	 * @param REfilePath - path to a random enviroment to apply to the model
+	 */
+	public void solve(String modelFilePath, String REfilePath) {
+
+		//check that the connection is alive
+		if(out.checkError()){
+			logger.info("Connection with LINE server has encoutner a problem, trying to reconnect...");
+			reConnect();
+		}
+
+		modelFilePath = modelFilePath.replace('\\', '/');
+		if (REfilePath != null)
+			REfilePath = REfilePath.replace('\\', '/');
+		// build the command
+		String command = "SOLVE " + modelFilePath;
+		if (REfilePath != null)
+			command += " " + REfilePath;
+
+		// "D://line_test//ofbiz ("+numExp+").xml D://line_test//ofbizRE ("+numExp+").xml";
+		logger.debug("Sending: " + command);
+
+		//reset the Logger in case a previous model with the same name have been specified
+		socketMessages.reset(modelFilePath);
+
+		// send the command
+		out.println(command);
+		out.flush();
+
+		return;
+
+	}
+
+
+
+	/**
+	 * Closes connections to an instance of LINE and, if the instance is local it terminates ir
+	 */
+	public void terminateLine() {
+		if (localInstance) {
+			//If LINE was launched by SPACE4Cloud close it
+			out.println("QUIT");
+			out.flush();
+			try {
+				proc.waitFor();
+			} catch (InterruptedException e) {
+				logger.error("Error in Quitting LINE",e);
+			}
+			
+			if (processMessages != null && processIn != null) {
+				processMessages.close();
+				try {
+					processIn.close();
+				} catch (IOException e) {
+					logger.error("Error in closing the process reader of LINE",e);
+				}
+			}
+		}
+
+		//otherwise just close the connection
+		closeConnections();
+
+	}
+
+	/**
+	 * Clear the handler from events of previous evaluations
+	 */
+	public void clear() {
+		socketMessages.clear();
+
+	}
+
+
+}
Index: src/de/uka/ipd/sdq/pcmsolver/transformations/line/LineServerHandlerFactory.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/transformations/line/LineServerHandlerFactory.java	(revision 0)
+++ src/de/uka/ipd/sdq/pcmsolver/transformations/line/LineServerHandlerFactory.java	(revision 0)
@@ -0,0 +1,37 @@
+package de.uka.ipd.sdq.pcmsolver.transformations.line;
+
+import org.apache.log4j.Logger;
+
+
+public class LineServerHandlerFactory {
+	
+	private static LineServerHandler handler = null;
+	private static String propfile = null; 
+	private static final Logger logger = Logger.getLogger(LineServerHandlerFactory.class);
+	public static LineServerHandler getHandler(){
+		if(propfile == null){
+			logger.error("No property file has been specified for LINE");
+			return null;
+		}
+		if(handler==null){
+			handler = new LineServerHandler(propfile);
+		}
+		return handler;
+	}
+	
+	/**
+	 * Destroys the instance of the handler
+	 */
+	public static void clearHandler(){
+		handler = null;
+	}
+
+	/**
+	 * Specify the path to the LINE.properties file containing details about the connection to the server and parameters to launch a new server
+	 * @param linePropFile
+	 */
+	public static void setLINEPropertyFile(String linePropFile) {
+		propfile = linePropFile;
+	}
+
+}
Index: src/de/uka/ipd/sdq/pcmsolver/transformations/line/MessageHandler.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/transformations/line/MessageHandler.java	(revision 0)
+++ src/de/uka/ipd/sdq/pcmsolver/transformations/line/MessageHandler.java	(revision 0)
@@ -0,0 +1,183 @@
+/*******************************************************************************
+ * Copyright 2014 Giovanni Paolo Gibilisco
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package de.uka.ipd.sdq.pcmsolver.transformations.line;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.lang.time.StopWatch;
+import org.apache.log4j.Logger;
+
+public class MessageHandler implements Runnable {
+	private BufferedReader in;
+	private boolean read = true;
+	private boolean running = false;
+	private boolean connected = false;
+	private Map<String, String> evaluations = new HashMap<String, String>();
+	private Map<String, StopWatch> timers = new HashMap<String, StopWatch>();
+	private static final Logger logger = Logger.getLogger(MessageHandler.class);
+	private static final Object SUBMITTED = "SUBMITTED";
+	private static final Object SOLVED = "SOLVED";
+
+	String prefix = "";
+
+	public MessageHandler(BufferedReader in, String prefix) {
+		this.in = in;
+		if (prefix != null)
+			this.prefix = prefix;
+	}
+
+	public synchronized void close() {
+		read = false;
+	}
+
+	public synchronized boolean isConnected() {
+		return connected;
+	}
+
+	public synchronized boolean isModelEvaluated(String modelPath) {
+		modelPath = Paths.get(modelPath).toString();
+		return evaluations.containsKey(modelPath)
+				&& evaluations.get(modelPath).equals("SOLVED");
+		// TODO clear the model form the map?
+	}
+
+	private synchronized boolean isRead() {
+		return read;
+	}
+
+	public synchronized boolean isRunning() {
+		return running;
+	}
+
+	private void logTime(String modelName, long time) {
+		logger.info(modelName + ", " + evaluations.get(modelName) + ", "
+				+ time);
+	}
+
+	@Override
+	public void run() {
+		while (isRead())
+			try {
+				if(!in.ready())
+					Thread.sleep(100);
+				if (in.ready()) {
+					String line = in.readLine();
+					logger.debug("LINE " + prefix + ": " + line);
+
+					// set the starting
+					if (line.contains("Listening on port"))
+						setRunning(true);
+					if (line.contains("LINE READY"))
+						setConnected(true);
+					if (line.contains("LINE STOP"))
+						setRunning(false);
+					if (line.contains("ERROR"))
+						manageError(line);
+					else if (line.contains("MODEL"))
+						updateModelEvaluation(line);
+
+				}
+
+			} catch (IOException e) {
+				if (e.getMessage().equals("Stream closed"))
+					logger.debug("LINE " + prefix + ": " + e.getMessage());
+				else
+					logger.error("Error in reading from LINE output",e);
+			} catch (InterruptedException e) {
+				logger.error("Error in reading from LINE output",e);
+			}
+	}
+
+	private void manageError(String line) {
+		logger.error("LINE error:"+line);		
+	}
+
+	private synchronized void setConnected(boolean connected) {
+		this.connected = connected;
+	}
+
+	private synchronized void setRunning(boolean running) {
+		this.running = running;
+	}
+
+	private synchronized void updateModelEvaluation(String message) {
+		message = message.trim().replaceAll(" +", " ");
+		String[] tokens = message.split(" ");
+		
+		int offset = 0;
+		
+		String modelName = tokens[1];
+		
+		while (modelName.indexOf("xml") == -1) {
+			modelName += " " + tokens[2 + offset];
+			offset++;
+		}
+		
+		modelName = modelName.replace("_line.xml", ".xml");
+		modelName = Paths.get(modelName).toString();
+		String status = null;
+		if (tokens.length == (4 + offset))
+			status = tokens[3 + offset];
+		else
+			status = tokens[2 + offset];
+		evaluations.put(modelName, status);
+
+		if (status.equals(SUBMITTED)) {
+			StopWatch timer = new StopWatch();
+			timer.start();
+			timers.put(modelName, timer);
+		} else if (status.equals(SOLVED)) {
+			long time = -1;
+			try {
+				if(timers.containsKey(modelName)){
+					timers.get(modelName).stop();
+					time = timers.get(modelName).getTime();
+				}
+			} catch (IllegalStateException e) {
+				logger.error("Error in taking the time, will put -1",e);				
+			} finally
+			{
+				logTime(modelName,time);
+			}
+
+		}
+
+	}
+
+	/**
+	 * Removes the specified model from the list of model waiting from an evaluation
+	 * @param modelFilePath
+	 */
+	public synchronized void reset(String modelFilePath) {
+		evaluations.remove(modelFilePath);
+		timers.remove(modelFilePath);
+
+	}
+
+	/**
+	 * Clears the list of models waiting for an evaluation
+	 */
+	public void clear() {
+		evaluations.clear();
+		timers.clear();
+
+	}
+
+}
Index: src/de/uka/ipd/sdq/pcmsolver/transformations/pcm2lqn/Pcm2LqnStrategy.java
===================================================================
--- src/de/uka/ipd/sdq/pcmsolver/transformations/pcm2lqn/Pcm2LqnStrategy.java	(revision 26823)
+++ src/de/uka/ipd/sdq/pcmsolver/transformations/pcm2lqn/Pcm2LqnStrategy.java	(working copy)
@@ -1,13 +1,21 @@
+/*
+ * 
+ */
 package de.uka.ipd.sdq.pcmsolver.transformations.pcm2lqn;
 
 import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -24,10 +32,13 @@
 import de.uka.ipd.sdq.pcmsolver.runconfig.PCMSolverWorkflowRunConfiguration;
 import de.uka.ipd.sdq.pcmsolver.transformations.ContextWrapper;
 import de.uka.ipd.sdq.pcmsolver.transformations.SolverStrategy;
+import de.uka.ipd.sdq.pcmsolver.transformations.line.LineServerHandler;
+import de.uka.ipd.sdq.pcmsolver.transformations.line.LineServerHandlerFactory;
 import de.uka.ipd.sdq.pcmsolver.visitors.UsageModelVisitor;
 import de.uka.ipd.sdq.pcmsolver.visualisation.LQNHtmlResultGenerator;
 import de.uka.ipd.sdq.pcmsolver.visualisation.LQNResultEditorInput;
 
+// TODO: Auto-generated Javadoc
 /**
  * This is an excerpt of Heiko's dissertation (see below for link)
  * 
@@ -72,29 +83,61 @@
  */
 public class Pcm2LqnStrategy implements SolverStrategy {
 
-	private static Logger logger = Logger.getLogger(Pcm2LqnStrategy.class
-			.getName());
+	/** The logger. */
+	private static Logger logger = Logger.getLogger(Pcm2LqnStrategy.class.getName());
 
 	// the following filenames should be OS-independent
+	/** The filename input xml. */
 	private String filenameInputXML;
+
+	/** The filename result human readable. */
 	private String filenameResultHumanReadable;
+
+	/** The filename result xml. */
 	private String filenameResultXML;
+
+	/** The filename lqn. */
 	private String filenameLQN;
 
 	// the lqn tools should be in the system path
+	/** The Constant FILENAME_LQNS. */
 	private static final String FILENAME_LQNS = "lqns";
+
+	/** The Constant FILENAME_LQSIM. */
 	private static final String FILENAME_LQSIM = "lqsim";
+
+	/** The Constant FILENAME_LQSIM. */
+	private static final String FILENAME_LINE = "LINE";
+
+	/** The Constant FILENAME_LQN2XML. */
 	private static final String FILENAME_LQN2XML = "lqn2xml";
 
 	// Return values of lqns
+	/** The Constant LQNS_RETURN_SUCCESS. */
 	private static final int LQNS_RETURN_SUCCESS = 0;
+
+	/** The Constant LQNS_RETURN_MODEL_FAILED_TO_CONVERGE. */
 	private static final int LQNS_RETURN_MODEL_FAILED_TO_CONVERGE = 1;
+
+	/** The Constant LQNS_RETURN_INVALID_INPUT. */
 	private static final int LQNS_RETURN_INVALID_INPUT = 2;
+
+	/** The Constant LQNS_RETURN_FATAL_ERROR. */
 	private static final int LQNS_RETURN_FATAL_ERROR = -1;
 
+	/** The overall duration. */
 	private long overallDuration = 0;
+
+
+
+	/** The config. */
 	private PCMSolverWorkflowRunConfiguration config;
 
+	/**
+	 * Instantiates a new pcm2 lqn strategy.
+	 *
+	 * @param configuration the configuration
+	 */
 	public Pcm2LqnStrategy(PCMSolverWorkflowRunConfiguration configuration) {
 		config = configuration;
 
@@ -109,131 +152,234 @@
 				+ System.getProperty("file.separator") + "pcm2lqn" + timestamp
 				+ ".out";
 		filenameResultXML = getOutputFolder()
-				+ System.getProperty("file.separator") + "pcm2lqn_result"
-				+ timestamp + ".xml";
+				+ System.getProperty("file.separator") + "pcm2lqn"
+				+ timestamp + ".lqxo";
 		filenameLQN = getOutputFolder() + System.getProperty("file.separator")
 				+ "pcm2lqn" + timestamp + ".lqn";
+
 	}
 
+	/**
+	 * Gets the filename result xml.
+	 *
+	 * @return the filename result xml
+	 */
 	public String getFilenameResultXML() {
 		return filenameResultXML;
 	}
 
+	/**
+	 * Gets the output folder.
+	 *
+	 * @return the output folder
+	 */
 	private String getOutputFolder() {
 		if (getSolverProgramName().equals(FILENAME_LQNS)) {
 			return config.getLqnsOutputDir();
+		} else if (getSolverProgramName().equals(FILENAME_LINE)) {
+			return config.getLINEOutputDir();
 		} else {
 			return config.getLqsimOutputDir();
 		}
 	}
 
+	/**
+	 * Instantiates a new pcm2 lqn strategy.
+	 */
 	public Pcm2LqnStrategy() {
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.pcmsolver.transformations.SolverStrategy#loadTransformedModel(java.lang.String)
+	 */
 	public void loadTransformedModel(String fileName) {
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.pcmsolver.transformations.SolverStrategy#solve()
+	 */
 	public void solve() {
 		String solverProgram = getSolverProgramName();
 		String lqnsOutputType = getLqnsOutputTypeName();
 		String lqnSimOutputType = getLqsimOutputTypeName();
-		
+
 		String options = "";
 
 		String resultFile = "";
 		String inputFile = "";
+		String xmlresultFile = "";
 
 		long timeBeforeCalc = System.nanoTime();
 
 		int exitVal = LQNS_RETURN_FATAL_ERROR;
 		String errorMessages = "";
-		
+
 		try {
 			String command = "";
-			
-			
-			
+
 			// Process proc = null;
 			if (solverProgram.equals(FILENAME_LQNS)) {
-				
-				// check whether Pragmas (see LQN documentation) are used and if yes, set -P option
-				if (!config.getStopOnMessageLossLQNS() 
-						|| !"".equals(config.getPragmas())){
+
+				// check whether Pragmas (see LQN documentation) are used and if
+				// yes, set -P option
+				if (!config.getStopOnMessageLossLQNS()
+						|| !"".equals(config.getPragmas())) {
 					options += " -P ";
-					if (!config.getStopOnMessageLossLQNS()){
-						options += "stop-on-message-loss=false "; 
+					if (!config.getStopOnMessageLossLQNS()) {
+						options += "stop-on-message-loss=false ";
 					}
-					if (!"".equals(config.getPragmas())){
+					if (!"".equals(config.getPragmas())) {
 						options += config.getPragmas();
 					}
 				}
-				if (lqnsOutputType.equals(MessageStrings.LQN_OUTPUT_HUMAN)
-					) {
-					inputFile = filenameLQN;
+				if (lqnsOutputType.equals(MessageStrings.LQN_OUTPUT_HUMAN)) {
+					// inputFile = filenameLQN;
+					// modified from filenameLQN
+					inputFile = filenameInputXML;
 					resultFile = filenameResultHumanReadable;
-					command = solverProgram
-							+ options
-							+ " -o" + resultFile + " " + inputFile;
+					xmlresultFile = filenameResultXML;
+					command = solverProgram + options + " -o " + resultFile
+							+ " " + inputFile;
 				} else if (lqnsOutputType.equals(MessageStrings.LQN_OUTPUT_XML)
-						|| lqnsOutputType.equals(MessageStrings.LQN_OUTPUT_HTML)) {
+						|| lqnsOutputType
+						.equals(MessageStrings.LQN_OUTPUT_HTML)) {
 					// The lqns produces XML output when the input is as well in
 					// XML
-					inputFile = filenameResultXML;
-					resultFile = inputFile;
-					command = solverProgram
-							+ options
-							+ " " + inputFile;
+					//inputFile = filenameResultXML;
+					//resultFile = inputFile;
+					inputFile = filenameInputXML;					
+					resultFile = filenameResultXML;
+					xmlresultFile = filenameResultXML;
+					command = solverProgram + options + " " + inputFile;
 				}
 			} else if (solverProgram.equals(FILENAME_LQSIM)) {
 				// LQSim config
 				String blocks = config.getLQSimBlocks();
 				String runtime = config.getLQSimRuntime();
-				
-				if (runtime != null && runtime != ""){
-					options += " -A "+runtime;
+
+				if (runtime != null && runtime != "") {
+					options += " -A " + runtime;
 				}
-				if (blocks != null && blocks != ""){
-					options += " -B "+blocks;
+				if (blocks != null && blocks != "") {
+					options += " -B " + blocks;
 				}
-				if (!config.getStopOnMessageLossLQSim()){
+				if (!config.getStopOnMessageLossLQSim()) {
 					options += " -P stop-on-message-loss=false";
 				}
-				
+
 				if (lqnSimOutputType.equals(MessageStrings.LQN_OUTPUT_HUMAN)
-					|| lqnSimOutputType.equals(MessageStrings.LQN_OUTPUT_HTML)) {
+						|| lqnSimOutputType
+						.equals(MessageStrings.LQN_OUTPUT_HTML)) {
 					inputFile = filenameLQN;
 					resultFile = filenameResultHumanReadable;
-					command = solverProgram
-							+ options
-							+ " -o" + resultFile + " " + inputFile;
+					command = solverProgram + options + " -o" + resultFile
+							+ " " + inputFile;
 				} else if (lqnSimOutputType
 						.equals(MessageStrings.LQN_OUTPUT_XML)) {
 					// The lqsim produces XML output when the input is as well
 					// in XML
-					inputFile = filenameResultXML;
-					resultFile = inputFile;
-					command = solverProgram
-							+ options
-							+ " " + inputFile;
+					//inputFile = filenameResultXML;
+					//resultFile = inputFile;
+					inputFile = filenameInputXML;					
+					resultFile = filenameResultXML;
+					xmlresultFile = filenameResultXML;
+					//command = solverProgram + options + " " + inputFile;
+
+					// NEW CODE
+					//
+					//Read the XML input file encoding the LQN instance
+					FileReader fr = new FileReader(inputFile);
+					BufferedReader br = new BufferedReader(fr);
+					//Skip the first line (wrong encoding ASCII)
+					br.readLine();
+					//Read the following lines
+					List<String> content = new ArrayList<String>();
+					String line = br.readLine();
+					while (line != null) {
+						content.add(line + "\n");
+						line = br.readLine();
+					}
+					//Close the file
+					br.close();
+					fr.close();
+					//Delete the file
+					File f = new File(inputFile);
+					f.delete();
+					//Create a new file with the same name and start writing in it
+					FileWriter fw = new FileWriter(f);
+					BufferedWriter bw = new BufferedWriter(fw);
+					//Write the correct XML header (encoding us-ascii)
+					bw.write("<?xml version=\"1.0\" encoding=\"us-ascii\"?>\n");
+					bw.flush();
+					//Write all the following lines
+					for (String s : content) {
+						bw.write(s);
+						bw.flush();
+					}
+					//Close the file
+					bw.close();
+					fw.close();
+					//
+					// END NEW CODE
+
+					command = solverProgram + options + " " + inputFile;
 				}
 			}
-			logger.warn("Calling LQN analysis tool with "+command);
-			ProcessBuilder pb = new ProcessBuilder(splitToCommandArray(command));
-			pb.redirectErrorStream(true);
-			Process proc = pb.start();
+			//Perfromance Engine Solution Method
+			else if(solverProgram.equals(FILENAME_LINE)){	
+				inputFile = filenameInputXML;
+				resultFile = filenameResultXML;
 
-			// StreamGobbler errorGobbler = new
-			// StreamGobbler(proc.getErrorStream(), "ERROR");
-			// StreamGobbler outputGobbler = new
-			// StreamGobbler(proc.getInputStream(), "OUTPUT");
-			// errorGobbler.start();
-			// outputGobbler.start();
+				//fix the xml header
+				fixXmlHeader(inputFile);
+
+				LineServerHandlerFactory.setLINEPropertyFile(config.getLINEPropFile());
+				LineServerHandler lineHandler = LineServerHandlerFactory.getHandler();
+				//connect to LINE
+				lineHandler.connectToLINEServer();			
+				String  inputFileAbsPath = new File(inputFile).getAbsolutePath();
+				
+				//solve without random enviroment
+				lineHandler.solve(inputFileAbsPath,null);		
+				// wait for the model to be solved
+				while (!lineHandler.isSolved(inputFileAbsPath))
+					try {
+						Thread.sleep(100);
+					} catch (InterruptedException e) {
+						logger.error("Error watiting for LINE solution",e);
+					}
+						
+				//terminate the connection
+				lineHandler.terminateLine();				
 
-			errorMessages = readStream(proc.getInputStream());
+			}
 
-			exitVal = proc.waitFor();
-			proc.destroy();
+			//if we did not use line the proceed with executable invocation
+			if(!solverProgram.equals(FILENAME_LINE)){
+				logger.warn("Calling LQN analysis tool with " + command);
+				ProcessBuilder pb = new ProcessBuilder(splitToCommandArray(command));
+				pb.redirectErrorStream(true);
 
+				long lStartTime = System.nanoTime();
+				Process proc = pb.start();
+				// StreamGobbler errorGobbler = new
+				// StreamGobbler(proc.getErrorStream(), "ERROR");
+				// StreamGobbler outputGobbler = new
+				// StreamGobbler(proc.getInputStream(), "OUTPUT");
+				// errorGobbler.start();
+				// outputGobbler.start();
+				System.out.println(readStream(proc.getInputStream()));
+				exitVal = proc.waitFor();
+
+				//some tasks
+				long lEndTime = System.nanoTime();
+
+				long difference = lEndTime - lStartTime;
+
+				System.out.println("Evaulated in: " + difference/1000000);
+
+				proc.destroy();
+			}
 		} catch (Throwable e) {
 			logger.error("Running " + solverProgram + " failed!");
 			throw new RuntimeException(e);
@@ -245,63 +391,138 @@
 		overallDuration += duration;
 		logger.warn("Finished Running " + solverProgram + ":\t\t" + duration
 				+ " ms");
-		logger
-				.warn("Completed Analysis:\t\t" + overallDuration
-						+ " ms overall");
+		logger.warn("Completed Analysis:\t\t" + overallDuration + " ms overall");
 
 		/* return if results are available or throw exception. */
-		if (exitVal == LQNS_RETURN_SUCCESS) {
-			logger.warn("Analysis Result has been written to: " + resultFile);
-			if (lqnsOutputType.equals(MessageStrings.LQN_OUTPUT_HTML)){
-				//showOutput(resultFile);
-				LQNHtmlResultGenerator result = new LQNHtmlResultGenerator(resultFile);
-				result.display();
-			}
-			
-		} else if (exitVal == LQNS_RETURN_MODEL_FAILED_TO_CONVERGE){
-			logger.error(solverProgram + " exited with " + exitVal
+		//If we are using LQNS
+		if(!solverProgram.equals(FILENAME_LINE)){
+			if (exitVal == LQNS_RETURN_SUCCESS) {
+				logger.warn("Analysis Result has been written to: " + resultFile);
+				if (lqnsOutputType.equals(MessageStrings.LQN_OUTPUT_HTML)&& config.isShowHtmlResults()) {
+					// showOutput(resultFile);
+					LQNHtmlResultGenerator result = new LQNHtmlResultGenerator(
+							xmlresultFile);
+					result.display();
+				}
+
+			} else if (exitVal == LQNS_RETURN_MODEL_FAILED_TO_CONVERGE) {
+				logger.error(solverProgram
+						+ " exited with "
+						+ exitVal
 						+ ": The model failed to converge. Results are most likely inaccurate. ");
-			logger.warn("Analysis Result has been written to: " + resultFile);
-		} else {
-			String message = "";
-			if (exitVal == LQNS_RETURN_INVALID_INPUT) {
-				message = solverProgram + " exited with " + exitVal
-						+ ": Invalid Input.";
-			} else if (exitVal == LQNS_RETURN_FATAL_ERROR) {
-				message = solverProgram + " exited with " + exitVal
-						+ ": Fatal error";
+				logger.warn("Analysis Result has been written to: " + resultFile);
 			} else {
-				message = solverProgram
-						+ " returned an unrecognised exit value "
-						+ exitVal
-						+ ". Key: 0 on success, 1 if the model failed to meet the convergence criteria, 2 if the input was invalid, 4 if a command line argument was incorrect, 8 for file read/write problems and -1 for fatal errors. If multiple input files are being processed, the exit code is the bit-wise OR of the above conditions.";
+				String message = "";
+				if (exitVal == LQNS_RETURN_INVALID_INPUT) {
+					message = solverProgram + " exited with " + exitVal
+							+ ": Invalid Input.";
+				} else if (exitVal == LQNS_RETURN_FATAL_ERROR) {
+					message = solverProgram + " exited with " + exitVal
+							+ ": Fatal error";
+				} else {
+					message = solverProgram
+							+ " returned an unrecognised exit value "
+							+ exitVal
+							+ ". Key: 0 on success, 1 if the model failed to meet the convergence criteria, 2 if the input was invalid, 4 if a command line argument was incorrect, 8 for file read/write problems and -1 for fatal errors. If multiple input files are being processed, the exit code is the bit-wise OR of the above conditions.";
+				}
+				message += "\nFurther errors: " + errorMessages;
+				logger.error(message);
+				throw new RuntimeException(message);
 			}
-			message += "\nFurther errors: "+errorMessages;
-			logger.error(message);
-			throw new RuntimeException(message);
+		}
+		//if we are using the Performance Engine Solver
+		else{
+			logger.info("Using the perfromance Engine Solver");
+			logger.info("Exit val: "+exitVal);
+			logger.info("Results writte in: "+resultFile);
+		}
+	}
+
+	
+	/**
+	 * Original patch from Gregory Franks, usex to fix the xml header of the generated file
+	 * @param inputFile
+	 * @throws FileNotFoundException
+	 * @throws IOException
+	 */
+	private void fixXmlHeader(String inputFile) throws FileNotFoundException,
+			IOException {
+		//Read the XML input file encoding the LQN instance
+		FileReader fr = new FileReader(inputFile);
+		BufferedReader br = new BufferedReader(fr);
+		//Skip the first line (wrong encoding ASCII)
+		br.readLine();
+		//Read the following lines
+		List<String> content = new ArrayList<String>();
+		String line = br.readLine();
+		while (line != null) {
+			content.add(line + "\n");
+			line = br.readLine();
 		}
+		//Close the file
+		br.close();
+		fr.close();
+		//Delete the file
+		File f = new File(inputFile);
+		f.delete();
+		//Create a new file with the same name and start writing in it				
+		File recordFile = new File(inputFile);			
+		FileWriter recordFw = new FileWriter(recordFile);
+		BufferedWriter recordBw = new BufferedWriter(recordFw);
+		//Write the correct XML header (encoding us-ascii)
+		recordBw.write("<?xml version=\"1.0\" encoding=\"us-ascii\"?>\n");
+		recordBw.flush();
+		//Write all the following lines
+		for (String s : content) {
+			recordBw.write(s);
+			recordBw.flush();
+		}
+		//Close the file
+		recordBw.close();
+		recordFw.close();
 	}
 
+
+
+	/**
+	 * Gets the solver program name.
+	 *
+	 * @return the solver program name
+	 */
 	private String getSolverProgramName() {
 		if (config.getSolver().equals(MessageStrings.LQNS_SOLVER)) {
 			return FILENAME_LQNS;
-		} else {
+		} else if (config.getSolver().equals(MessageStrings.PERFENGINE_SOLVER)) {
+			return FILENAME_LINE;
+		} else{
 			return FILENAME_LQSIM;
 		}
 	}
 
+
+	/**
+	 * Gets the lqns output type name.
+	 *
+	 * @return the lqns output type name
+	 */
 	private String getLqnsOutputTypeName() {
 		return config.getLqnsOutput();
 	}
+	
 
+	/**
+	 * Gets the lqsim output type name.
+	 *
+	 * @return the lqsim output type name
+	 */
 	private String getLqsimOutputTypeName() {
 		return config.getLqsimOutput();
 	}
 
 	/**
 	 * Reads the output file and shows its content in a new text editor window.
-	 * 
-	 * @param filename
+	 *
+	 * @param filename the filename
 	 */
 	private void showOutput(String filename) {
 		FileInputStream fis = null;
@@ -322,9 +543,9 @@
 		String content = new String(b);
 
 		final String htmlText = getHtmlForLqnResult(content);
-		
-//		ResultWindow rw = new ResultWindow(content);
-//		rw.open();
+
+		// ResultWindow rw = new ResultWindow(content);
+		// rw.open();
 
 		Display.getDefault().asyncExec(new Runnable() {
 			public void run() {
@@ -340,20 +561,30 @@
 				}
 			}
 		});
-		
+
 	}
 
+	/**
+	 * Gets the html for lqn result.
+	 *
+	 * @param lqnResult the lqn result
+	 * @return the html for lqn result
+	 */
 	private String getHtmlForLqnResult(String lqnResult) {
-		String htmlText = "<html><head><title>LQN Results</title></head>" +
-				"<body><pre>" +
-				lqnResult +
-				"</pre></body></html>";
+		String htmlText = "<html><head><title>LQN Results</title></head>"
+				+ "<body><pre>" + lqnResult + "</pre></body></html>";
 		return htmlText;
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.pcmsolver.transformations.SolverStrategy#storeTransformedModel(java.lang.String)
+	 */
 	public void storeTransformedModel(String fileName) {
 	}
 
+	/* (non-Javadoc)
+	 * @see de.uka.ipd.sdq.pcmsolver.transformations.SolverStrategy#transform(de.uka.ipd.sdq.pcmsolver.models.PCMInstance)
+	 */
 	public void transform(PCMInstance model) {
 		long startTime = System.nanoTime();
 
@@ -379,11 +610,17 @@
 		logger.warn("Finished PCM2LQN:\t\t" + duration2 + " ms");
 	}
 
+	/**
+	 * Run pcm2 lqn.
+	 *
+	 * @param model the model
+	 */
 	private void runPcm2Lqn(PCMInstance model) {
 
-		LqnBuilder lqnBuilder = new LqnBuilder(config.isInfiniteTaskMultiplicity());
-		
-		if (getSolverProgramName().equals(FILENAME_LQSIM)){
+		LqnBuilder lqnBuilder = new LqnBuilder(
+				config.isInfiniteTaskMultiplicity());
+
+		if (getSolverProgramName().equals(FILENAME_LQSIM)) {
 			lqnBuilder.setIsLQSimAnalysis(true);
 		}
 
@@ -397,8 +634,8 @@
 
 		lqnBuilder.finalizeLqnModel(config);
 
-		LqnXmlHandler lqnXmlHandler = new LqnXmlHandler(lqnBuilder
-				.getLqnModel());
+		LqnXmlHandler lqnXmlHandler = new LqnXmlHandler(
+				lqnBuilder.getLqnModel());
 		lqnXmlHandler.saveModelToXMI(filenameInputXML);
 
 		Pcm2LqnHelper.clearGuidMap();
@@ -439,11 +676,12 @@
 				logger.info("lqn2xml terminated successfully");
 			} else {
 				logger.error("lqn2xml terminated unsuccessfully. Exit value was "
-								+ exitVal + ".");
+						+ exitVal + ".");
 			}
 
 		} catch (Throwable e) {
-			logger.error("lqn2xml terminated unsuccessfully. Exception "+e.getMessage());
+			logger.error("lqn2xml terminated unsuccessfully. Exception "
+					+ e.getMessage());
 			e.printStackTrace();
 		}
 	}
@@ -466,7 +704,7 @@
 			// Process proc = Runtime.getRuntime().exec(
 			// FILENAME_LQN2XML+" -o" + FILENAME_RESULT_XML +
 			// " -Oxml " + FILENAME_INPUT_XML);
-			//			
+			//
 			Process proc = pb.start();
 
 			// StreamGobbler errorGobbler = new StreamGobbler(proc
@@ -484,31 +722,35 @@
 			if (exitVal == 0) {
 				logger.info("lqn2xml terminated sucessfully");
 			} else {
-				logger
-						.warn("lqn2xml terminated unsuccessfully. Exit value was "
-								+ exitVal + ".");
+				logger.warn("lqn2xml terminated unsuccessfully. Exit value was "
+						+ exitVal + ".");
 			}
 		} catch (Throwable e) {
 			e.printStackTrace();
 		}
 	}
 
+	/**
+	 * Run d solver.
+	 *
+	 * @param model the model
+	 */
 	private void runDSolver(PCMInstance model) {
 		// TODO: fix this (only uses one usage scenario):
 		UsageModelVisitor visitor = new UsageModelVisitor(model);
 		List<UsageScenario> scenarios = model.getUsageModel()
 				.getUsageScenario_UsageModel();
 		for (UsageScenario usageScenario : scenarios) {
-			visitor
-					.doSwitch(usageScenario
-							.getScenarioBehaviour_UsageScenario());
+			visitor.doSwitch(usageScenario.getScenarioBehaviour_UsageScenario());
 		}
 	}
 
 	/**
-	 * 
-	 * @param is
-	 * @return the concatenated String of all error messages encountered during the analysis
+	 * Read stream.
+	 *
+	 * @param is the is
+	 * @return the concatenated String of all error messages encountered during
+	 * the analysis
 	 */
 	private String readStream(InputStream is) {
 		String errorMessages = "";
@@ -533,12 +775,23 @@
 		return errorMessages;
 	}
 
+	/**
+	 * Split to command array.
+	 *
+	 * @param command the command
+	 * @return the string[]
+	 */
 	private String[] splitToCommandArray(String command) {
 		return command.split("\\s");
 	}
 
 	// FIXME: This is not a good way to remove get the debugging statements. Fix
 	// this when introducing a better configuration concept here.
+	/**
+	 * Checks if is debug.
+	 *
+	 * @return true, if is debug
+	 */
 	private boolean isDebug() {
 		int level = config.getDebugLevel();
 		if (level <= 1) {
@@ -561,7 +814,13 @@
 		// default:
 		// return Level.INFO;
 	}
-	
+
+	public String getFilenameInputXML() {
+		return filenameInputXML;
+	}
+
+
+
 }
 
 // TODO: Anne: delete this method and the related comments above if the changes
@@ -598,4 +857,7 @@
 			ioe.printStackTrace();
 		}
 	}
-}
\ No newline at end of file
+
+
+}
+
